<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Cooldown Multiplayer</title>
  <style>
    body { font-family: Montserrat, system-ui, -apple-system, sans-serif; background:#1e3c72; color:#fff; padding:30px; text-align:center; }
    input, button, select { font-size:1rem; padding:10px; margin:10px; border-radius:6px; border:none; }
    button { cursor:pointer }
    #game, #settingsContainer, #waitingHost { display:none; }
    #startGameBtn { display:none; }
    .player-grid { display:flex; justify-content:center; gap:16px; flex-wrap:wrap; margin:20px 0; }
    .player-card { background-color:rgba(255,255,255,0.1); padding:10px; border-radius:8px; min-width:140px; }
    .avatar { width:40px; height:40px; border-radius:50%; object-fit:cover; margin-bottom:5px; background:#fff; }
    #feedback { font-size:0.95rem; margin-top:8px; color:#90ee90; min-height:1.2em; }
    #status { opacity:.85; font-size:.95rem; min-height:1.2em; }
    .muted { opacity:.75 }
    .hidden { display:none }
  </style>
</head>
<body>
  <div id="welcome">
    <h1>Multiplayer Cooldown Trainer</h1>
    <input id="nameInput" placeholder="Ton pseudo..." maxlength="24"/>
    <select id="avatarSelect" title="Avatar">
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Fox">ü¶ä Avatar 1</option>
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Cat">üê± Avatar 2</option>
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Robot">ü§ñ Avatar 3</option>
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Dragon">üêâ Avatar 4</option>
    </select>
    <button id="joinBtn">Rejoindre</button>
    <div id="joinError" class="muted"></div>
  </div>

  <div id="settingsContainer">
    <h3>Param√©trer la partie</h3>
    <label>Nombre de tours:
      <input type="number" id="nbTours" value="10" min="1" max="50">
    </label>
    <label>Temps par tour (s):
      <input type="number" id="tempsTour" value="30" min="5" max="300">
    </label>
    <br>
    <button id="startGameBtn">üéÆ Lancer la partie</button>
  </div>

  <div id="waitingHost">
    <p>‚è≥ En attente que l'h√¥te lance la partie...</p>
  </div>

  <div id="game">
    <div id="status" class="muted"></div>
    <h2>Joueurs connect√©s</h2>
    <div class="player-grid" id="players"></div>

    <div id="sortDisplay" style="margin-top:16px;font-size:1.2rem;min-height:1.8em;"></div>
    <div id="timer" style="font-size:1.6rem;margin:10px 0;min-height:1.6em;"></div>

    <div id="answerSection" class="hidden">
      <input id="answerInput" placeholder="Cooldown en sec" inputmode="numeric" pattern="[0-9]*" maxlength="3">
      <button id="submitBtn">Envoyer</button>
      <div id="feedback"></div>
    </div>
  </div>

  <script type="module">
    import {
      initializeApp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, set, push, onValue, onDisconnect, update, get, remove,
      serverTimestamp, runTransaction, child
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    // --- Firebase ---
    const firebaseConfig = {
      apiKey: "AIzaSyBjkxLbnCBZYvcyNRrGxwphT6nCyPOcGfI",
      authDomain: "cdguesser.firebaseapp.com",
      projectId: "cdguesser",
      storageBucket: "cdguesser.appspot.com",
      messagingSenderId: "1094034546231",
      appId: "1:1094034546231:web:1baaeca8470b211cf529b2",
      databaseURL: "https://cdguesser-default-rtdb.europe-west1.firebasedatabase.app"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    // --- Refs ---
    const playersRef = ref(db, "players");
    const gameRef    = ref(db, "game"); // jeu unique; si tu veux des salons: "games/{roomId}"

    // --- State ---
    let playerId = null;
    let isHost = false;
    let cacheSpells = null;
    let timerInterval = null;
    let countdownPhase = "answer"; // "answer" | "between"
    let lastSpellKey = null; // pour √©viter la r√©p√©tition imm√©diate

    // --- UI helpers ---
    const el = (id)=>document.getElementById(id);
    const show = (id)=>el(id).classList.remove("hidden");
    const hide = (id)=>el(id).classList.add("hidden");

    // --- Spells ---
    async function loadSpells() {
      if (cacheSpells) return cacheSpells;
      const res = await fetch("data/championFull.json");
      const data = await res.json();
      const arr = [];
      for (const key in data.data) {
        const champ = data.data[key];
        champ.spells.forEach((spell, i) => {
          const cd = Array.isArray(spell.cooldown) ? spell.cooldown[0] : spell.cooldown;
          arr.push({
            champ: champ.name,
            key: ['Q','W','E','R'][i],
            cd: Number(cd),
            name: spell.name
          });
        });
      }
      cacheSpells = arr;
      return arr;
    }
    function randomSpell(spells) {
      let s;
      for (let tries=0; tries<5; tries++) {
        s = spells[Math.floor(Math.random()*spells.length)];
        const key = s.champ + "|" + s.key;
        if (key !== lastSpellKey) { lastSpellKey = key; break; }
      }
      return s;
    }

    // --- Join flow ---
    el("joinBtn").addEventListener("click", async () => {
      const name = el("nameInput").value.trim().slice(0,24);
      const avatar = el("avatarSelect").value;
      if (!name) { el("joinError").textContent = "Pseudo requis"; return; }

      const newPlayerRef = push(playersRef);
      playerId = newPlayerRef.key;
      await set(newPlayerRef, { name, avatar, score: 0, lastAnswer: null, joinedAt: serverTimestamp() });
      onDisconnect(newPlayerRef).remove();

      el("welcome").style.display = "none";
      el("game").style.display = "block";

      // Si pas d'h√¥te -> toi
      const gameSnap = await get(gameRef);
      const gameData = gameSnap.val();
      if (!gameData || !gameData.host) {
        isHost = true;
        await update(gameRef, { host: playerId });
        el("settingsContainer").style.display = "block";
        el("startGameBtn").style.display = "inline-block";
        el("waitingHost").style.display = "none";
        el("status").textContent = "Vous √™tes l'h√¥te.";
      } else {
        isHost = (gameData.host === playerId);
        if (!isHost) {
          el("waitingHost").style.display = "block";
          el("status").textContent = "En attente du lancement par l'h√¥te‚Ä¶";
        }
      }
    });

    // --- Players list live ---
    const playersList = el("players");
    onValue(playersRef, (snapshot) => {
      const data = snapshot.val() || {};
      playersList.innerHTML = "";
      for (const id in data) {
        const p = data[id];
        const card = document.createElement("div");
        card.className = "player-card";
        card.innerHTML = `
          <img src="${p.avatar}" class="avatar" alt="">
          <div><strong>${escapeHtml(p.name||"")}</strong></div>
          <div>Score : ${Number(p.score)||0}</div>`;
        playersList.appendChild(card);
      }
      // si l'h√¥te est parti -> r√©assigner au premier joueur
      reassignHostIfNeeded(data);
    });

    async function reassignHostIfNeeded(playersObj) {
      const snap = await get(gameRef);
      const g = snap.val();
      if (!g || !g.host) return;
      if (!playersObj[g.host]) {
        const firstId = Object.keys(playersObj)[0];
        if (!firstId) {
          // plus personne : reset jeu
          await set(gameRef, {});
          return;
        }
        await update(gameRef, { host: firstId });
        if (firstId === playerId) {
          isHost = true;
          el("settingsContainer").style.display = "block";
          el("startGameBtn").style.display = "inline-block";
          el("waitingHost").style.display = "none";
          el("status").textContent = "Vous √™tes devenu l'h√¥te.";
        }
      }
    }

    // --- Start game (host only) ---
    el("startGameBtn").addEventListener("click", async () => {
      if (!isHost) return alert("Seul l'h√¥te peut lancer la partie !");
      const totalTurns = clampInt(el("nbTours").value, 1, 50);
      const turnDuration = clampInt(el("tempsTour").value, 5, 300);
      const spells = await loadSpells();

      const first = randomSpell(spells);
      await set(gameRef, {
        host: playerId,
        settings: { totalTurns, turnDuration, delayBetween: 3 },
        turn: 1,
        phase: "answer", // "answer" -> "between"
        sort: first,
        // on stocke le timestamp serveur pour caler le compte √† rebours
        tsStart: serverTimestamp()
      });

      el("settingsContainer").style.display = "none";
      el("waitingHost").style.display = "none";
    });

    // --- Submit answer ---
    el("submitBtn").addEventListener("click", async () => {
      const v = el("answerInput").value.trim();
      if (!/^\d{1,3}$/.test(v)) {
        el("feedback").textContent = "‚ö†Ô∏è Entrez un nombre (0‚Äì999).";
        return;
      }
      const val = clampInt(v, 0, 999);
      const g = (await get(gameRef)).val();
      if (!g || g.phase !== "answer") { el("feedback").textContent = "Tour verrouill√©."; return; }
      await set(ref(db, `answers/${g.turn}/${playerId}`), { value: val, at: serverTimestamp() });
      el("feedback").textContent = "‚úÖ R√©ponse enregistr√©e";
    });

    // --- Game loop (all clients √©coutent, mais seul l‚Äôh√¥te avance) ---
    onValue(gameRef, (snap) => {
      const game = snap.val();
      if (!game || !game.settings) return;
      renderGame(game);
      setupTimer(game);
    });

    function renderGame(game) {
      const { turn, settings, phase, sort } = game;
      const { totalTurns, delayBetween } = settings;
      if (turn > totalTurns) { finDePartie(); return; }

      el("answerSection").classList.toggle("hidden", phase !== "answer");
      el("sortDisplay").innerHTML = sort ? `<strong>${sort.champ} ${sort.key}</strong> ‚Äî ${sort.name}` : "";
      el("feedback").textContent = "";
      el("status").textContent = (phase === "answer")
        ? `Tour ${turn}/${totalTurns} ‚Äî R√©pondez !`
        : `Tour ${turn}/${totalTurns} termin√©. Prochain dans ${delayBetween}s‚Ä¶`;
    }

    function setupTimer(game) {
      clearInterval(timerInterval);
      const now = Date.now();
      const { settings, phase } = game;
      const per = (phase === "answer") ? settings.turnDuration : settings.delayBetween;
      if (!game.tsStart) { el("timer").textContent = ""; return; }

      // On estime l'offset serveur-client via le timestamp re√ßu c√¥t√© client (approche simple)
      // Pour une vraie pr√©cision: stocker tsStart et tsClientAtSet, puis calculer drift moyen.
      let secondsLeft = Math.max(0, per - Math.floor((now - new Date(game.tsStart).getTime())/1000));
      el("timer").textContent = `${secondsLeft}s`;

      timerInterval = setInterval(async () => {
        secondsLeft--;
        el("timer").textContent = `${secondsLeft}s`;
        if (secondsLeft <= 0) {
          clearInterval(timerInterval);
          if (isHost) {
            if (phase === "answer") await closeAndScoreTurn(game);
            else if (phase === "between") await startNextTurn(game);
          }
        }
      }, 1000);
    }

    async function closeAndScoreTurn(game) {
      // score des r√©ponses du tour courant
      const answersSnap = await get(ref(db, `answers/${game.turn}`));
      const answers = answersSnap.val() || {};
      const correct = Number(game.sort.cd);

      // incr√©menter (pas √©craser) le score des joueurs ayant r√©pondu
      const updates = [];
      for (const uid in answers) {
        const rep = Number(answers[uid].value);
        if (Number.isFinite(rep)) {
          const diff = Math.abs(rep - correct);
          const pts = Math.max(0, 5000 - diff * 500); // m√™me logique que toi
          updates.push(incrementScore(uid, pts));
        }
      }
      await Promise.all(updates);

      // passer en phase "between" (pause avant prochain tour)
      await update(gameRef, { phase: "between", tsStart: serverTimestamp() });
    }

    async function startNextTurn(prevGame) {
      const { turn, settings } = prevGame;
      if (turn >= settings.totalTurns) {
        await update(gameRef, { turn: settings.totalTurns + 1 }); // d√©clenche fin
        return;
      }
      const spells = await loadSpells();
      const next = randomSpell(spells);
      await set(gameRef, {
        host: prevGame.host,
        settings,
        turn: turn + 1,
        phase: "answer",
        sort: next,
        tsStart: serverTimestamp()
      });
    }

    function incrementScore(uid, delta) {
      const sref = ref(db, `players/${uid}/score`);
      return runTransaction(sref, (current) => (Number(current)||0) + delta);
    }

    function finDePartie() {
      el("sortDisplay").innerHTML = "üéâ Fin de la partie !";
      el("answerSection").classList.add("hidden");
      el("status").textContent = "Merci d‚Äôavoir jou√© !";
      el("timer").textContent = "";
    }

    // --- Utils ---
    function clampInt(val, min, max) {
      const n = parseInt(val, 10);
      if (isNaN(n)) return min;
      return Math.max(min, Math.min(max, n));
    }
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    }

    // Nettoyage interval √† l‚Äôunload
    window.addEventListener("beforeunload", ()=> clearInterval(timerInterval));
  </script>
</body>
</html>
