<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cooldown Multiplayer (Rooms)</title>
  <style>
    body { font-family: Montserrat, system-ui, -apple-system, sans-serif; background:#1e3c72; color:#fff; padding:30px; text-align:center; }
    input, button, select { font-size:1rem; padding:10px; margin:10px; border-radius:6px; border:none; }
    button { cursor:pointer }
    a.btn { text-decoration:none; background:#ffd700; color:#222; font-weight:700; padding:8px 12px; border-radius:8px; }
    #topRight { position:fixed; top:12px; right:12px; display:flex; gap:8px; z-index:10; }
    #game, #settingsContainer, #waitingHost { display:none; }
    #startGameBtn { display:none; }
    .player-grid { display:flex; justify-content:center; gap:16px; flex-wrap:wrap; margin:20px 0; }
    .player-card { background-color:rgba(255,255,255,0.1); padding:10px; border-radius:8px; min-width:140px; }
    .avatar { width:40px; height:40px; border-radius:50%; object-fit:cover; margin-bottom:5px; background:#fff; }
    #feedback { font-size:0.95rem; margin-top:8px; color:#90ee90; min-height:1.2em; }
    #status { opacity:.85; font-size:.95rem; min-height:1.2em; }
    .hidden { display:none }
    .muted { opacity:.75 }

    /* Timer progress bar (ultra-smooth) */
    #timerBarWrap { height:10px; background:rgba(255,255,255,0.15); border-radius:999px; overflow:hidden; max-width:520px; margin:6px auto 0; }
    #timerBar {
      height:100%;
      width:100%;
      background:linear-gradient(90deg,#22c55e,#3b82f6);
      transform-origin:left center;
      transform:scaleX(1);
      transition: background .2s;
      will-change: transform;
    }
    #timerBar.danger { background:#ef4444; }

    /* Fade-in transitions */
    .fade-in { animation: fadeIn .25s ease both; }
    @keyframes fadeIn { from { opacity:0; transform:translateY(6px); } to { opacity:1; transform:translateY(0); } }

    /* Leaderboard (room between) */
    #leaderboardSection { margin-top:18px; }
    .lb-row { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.08); margin:8px 0; transition: transform .25s ease, background-color .25s ease; }
    .lb-rank { width:34px; text-align:center; font-weight:800; }
    .lb-avatar { width:32px; height:32px; border-radius:50%; background:#fff; object-fit:cover; }
    .lb-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center; gap:6px; }
    .lb-score { font-weight:800; }
    .lb-delta { font-weight:800; margin-left:8px; }
    .lb-posdelta { font-weight:700; margin-left:8px; }
    .lb-1 { background:linear-gradient(90deg, rgba(255,215,0,.22), transparent); }
    .lb-2 { background:linear-gradient(90deg, rgba(192,192,192,.22), transparent); }
    .lb-3 { background:linear-gradient(90deg, rgba(205,127,50,.22), transparent); }

    .gain { background-color: rgba(76,175,80,0.18); }
    .loss { background-color: rgba(244,67,54,0.18); }
    .pulse { animation: pulse 0.9s ease-out 1; }
    .rise  { animation: rise 0.45s ease-out 1; }
    .fall  { animation: fall 0.45s ease-out 1; }
    @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.03)} 100%{transform:scale(1)} }
    @keyframes rise  { 0%{transform:translateY(6px)} 100%{transform:translateY(0)} }
    @keyframes fall  { 0%{transform:translateY(-6px)} 100%{transform:translateY(0)} }

    #betweenInfo { margin-top:16px; background:rgba(255,255,255,0.08); border-radius:10px; padding:10px 12px; max-width:520px; margin-left:auto; margin-right:auto; }

    /* Modal Hebdo */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:999; }
    .modal { background:#0f1d3a; border:1px solid rgba(255,255,255,.12); border-radius:14px; max-width:640px; width:92vw; padding:16px; text-align:left; }
    .modal h3 { margin-top:0; }
    .week-note { font-size:.9rem; opacity:.8; }
    .global-row { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.06); margin:6px 0; }
    .global-rank { width:32px; text-align:center; font-weight:800; }
    .global-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .close-btn { float:right; background:#ffd700; color:#222; font-weight:700; border:none; border-radius:8px; padding:6px 10px; cursor:pointer; }

    /* Podium between */
    #podium { margin-top:10px; text-align:left; max-width:520px; margin-left:auto; margin-right:auto; }
    .podium-row { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.06); margin:6px 0; }
    .podium-rank { width:28px; text-align:center; font-weight:800; }
    .podium-avatar { width:28px; height:28px; border-radius:50%; background:#fff; object-fit:cover; }
    .podium-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .podium-meta { font-weight:700; }

    /* Stats locales + Historique */
    #localRow { margin-top:14px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .chip { background:rgba(255,255,255,0.14); border:1px solid rgba(255,255,255,0.15); padding:8px 10px; border-radius:999px; font-size:.9rem; }
    #historyWrap { max-width:620px; margin:10px auto 0; text-align:left; }
    #historyList .hrow { display:flex; gap:8px; align-items:center; background:rgba(255,255,255,0.06); padding:8px 10px; border-radius:10px; margin:6px 0; }
    .badge { padding:2px 6px; border-radius:6px; font-weight:800; font-size:.8rem; margin-left:6px; }
    .b-perfect { background:#ffd700; color:#222; }
    .b-fast { background:#7ee787; color:#0a3622; }
    .b-close { background:#9cc3ff; color:#0c2147; }

    /* NEW: avatar preview l√©g√®rement plus grand dans le pr√©-lobby */
    #avatarPreview { width:48px; height:48px; border-radius:50%; background:#fff; object-fit:cover; }
  </style>
</head>
<body>
  <!-- Boutons en haut √† droite -->
  <div id="topRight">
    <a href="index.html" class="btn" title="Aller au mode Solo">üè† Solo</a>
    <a id="shareBtn" class="btn" href="#" title="Copier le lien du salon">üîó Lien du salon</a>
    <a id="openGlobalBtn" class="btn" href="#" title="Classement hebdo global">üèÜ Hebdo</a>
  </div>

  <div id="welcome">
    <h1>Multiplayer Cooldown Trainer</h1>
    <div id="roomInfo" class="muted" style="margin-bottom:8px;"></div>

    <input id="nameInput" placeholder="Ton pseudo..." maxlength="24"/>

    <!-- Aper√ßu avatar + select -->
    <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin-top:6px;">
      <select id="avatarSelect" title="Avatar">
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Fox">ü¶ä Avatar 1</option>
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Cat">üê± Avatar 2</option>
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Robot">ü§ñ Avatar 3</option>
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Dragon">üêâ Avatar 4</option>
      </select>
      <img id="avatarPreview" class="avatar" alt="aper√ßu avatar" />
    </div>

    <button id="joinBtn">Rejoindre</button>
    <!-- Rejoindre en un clic si profil sauvegard√© -->
    <button id="quickJoinBtn" class="hidden">‚ö° Rejoindre en un clic</button>

    <div id="joinError" class="muted"></div>

    <!-- Pr√©-lobby : liste des joueurs d√©j√† pr√©sents -->
    <div id="preLobby" style="margin-top:18px;">
      <h3 style="margin:8px 0;">Joueurs dans ce salon</h3>
      <div id="playersPreview" class="player-grid"></div>
    </div>
  </div>

  <div id="settingsContainer">
    <h3>Param√©trer la partie</h3>
    <label>Nombre de tours:
      <input type="number" id="nbTours" value="10" min="1" max="50">
    </label>
    <label>Temps par tour (s):
      <input type="number" id="tempsTour" value="30" min="5" max="300">
    </label>
    <div class="muted">Pause entre tours : 10s</div>
    <br>
    <button id="startGameBtn">üéÆ Lancer la partie</button>
  </div>

  <div id="waitingHost">
    <p>‚è≥ En attente que l'h√¥te lance la partie...</p>
  </div>

  <div id="game">
    <div id="status" class="muted"></div>
    <h2>Joueurs connect√©s</h2>
    <div class="player-grid" id="players"></div>

    <div id="sortDisplay" style="margin-top:16px;font-size:1.2rem;min-height:1.8em;"></div>

    <div id="timer" style="font-size:1.6rem;margin:10px 0;min-height:1.6em;"></div>
    <div id="timerBarWrap"><div id="timerBar"></div></div>

    <div id="answerSection" class="hidden">
      <input id="answerInput" placeholder="Cooldown en sec" inputmode="numeric" pattern="[0-9]*" maxlength="3">
      <button id="submitBtn">Envoyer</button>
      <div id="feedback"></div>
    </div>

    <div id="betweenInfo" class="hidden"></div>

    <div id="leaderboardSection" class="hidden">
      <h3 style="margin:8px 0;">Classement</h3>
      <div id="leaderboard" style="max-width:560px;margin:0 auto;text-align:left;"></div>
    </div>

    <div id="restartRow" style="margin-top:14px; display:none">
      <label style="font-size:.95rem">
        <input type="checkbox" id="resetScores" checked>
        R√©initialiser les scores
      </label>
      <button id="restartBtn">üîÅ Relancer la partie</button>
    </div>

    <!-- Stats locales + Historique -->
    <div id="localRow" class="hidden">
      <span class="chip" id="chipGames">Parties: 0</span>
      <span class="chip" id="chipRounds">Tours jou√©s: 0</span>
      <span class="chip" id="chipPerfect">Perfects: 0 (0%)</span>
      <span class="chip" id="chipAvg">Diff moyen: ‚Äî</span>
      <span class="chip" id="chipStreak">S√©rie perfect: 0</span>
      <button id="toggleHistory" class="btn">üìù Historique</button>
    </div>
    <div id="historyWrap" class="hidden">
      <div id="historyList"></div>
    </div>
  </div>

  <!-- Modal Classement Hebdo Global -->
  <div id="globalModal" class="modal-backdrop">
    <div class="modal">
      <button id="closeGlobal" class="close-btn">Fermer</button>
      <h3>üèÜ Classement hebdo ‚Äî <span id="weekLabel"></span></h3>
      <div class="week-note">R√©initialisation chaque lundi √† 00:00 (UTC).</div>
      <div id="globalList" style="margin-top:10px;"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, set, onValue, onDisconnect, update, get, remove,
      serverTimestamp, runTransaction, query, orderByChild, limitToLast
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    // -------- Firebase --------
    const firebaseConfig = {
      apiKey: "AIzaSyBjkxLbnCBZYvcyNRrGxwphT6nCyPOcGfI",
      authDomain: "cdguesser.firebaseapp.com",
      projectId: "cdguesser",
      storageBucket: "cdguesser.appspot.com",
      messagingSenderId: "1094034546231",
      appId: "1:1094034546231:web:1baaeca8470b211cf529b2",
      databaseURL: "https://cdguesser-default-rtdb.europe-west1.firebasedatabase.app"
    };
    const app  = initializeApp(firebaseConfig);
    const db   = getDatabase(app);
    const auth = getAuth(app);

    // -------- Constantes jeu --------
    const DELAY_BETWEEN = 10;  // pause FIXE 10s
    const SEASON_ID = "S1";
    const FAST_MS = 3000;      // < 3 sec => badge Rapid

    // -------- Room handling --------
    function getRoomId() {
      const url = new URL(window.location.href);
      let id = url.searchParams.get('room');
      if (!/^[a-z0-9]{2,20}$/i.test(id || '')) {
        id = Math.random().toString(36).slice(2, 8);
        url.searchParams.set('room', id);
        history.replaceState(null, '', url.toString());
      }
      return id;
    }
    const ROOM_ID = getRoomId();
    const playersRef  = ref(db, `rooms/${ROOM_ID}/players`);
    const stateRef    = ref(db, `rooms/${ROOM_ID}/state`);
    const answersRef  = ref(db, `rooms/${ROOM_ID}/answers`);

    // Global leaderboard refs
    function getISOWeekKey(d=new Date()) {
      const date = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
      const dayNum = (date.getUTCDay() + 6) % 7; // Mon=0..Sun=6
      date.setUTCDate(date.getUTCDate() - dayNum + 3);
      const firstThu = new Date(Date.UTC(date.getUTCFullYear(),0,4));
      const week = 1 + Math.round(((date - firstThu)/86400000 - 3 + ((firstThu.getUTCDay()+6)%7)) / 7);
      const year = date.getUTCFullYear();
      return `${year}-W${String(week).padStart(2,'0')}`;
    }
    const WEEK_ID = getISOWeekKey();

    function globalWeekRef(uid) { return ref(db, `leaderboards/weeks/${WEEK_ID}/${uid}`); }
    function globalSeasonRef(uid){ return ref(db, `leaderboards/seasons/${SEASON_ID}/${uid}`); }
    const profilesRef = (uid)=> ref(db, `profiles/${uid}`);

    // UI share
    const shareBtn = document.getElementById('shareBtn');
    document.getElementById('roomInfo').textContent = `Salon : ${ROOM_ID}`;
    shareBtn.href = window.location.href;
    shareBtn.onclick = async (e) => {
      e.preventDefault();
      try { await navigator.clipboard.writeText(window.location.href); shareBtn.textContent = '‚úÖ Lien copi√©'; setTimeout(()=>shareBtn.textContent='üîó Lien du salon',1500);} catch(_) {}
    };

    // -------- State --------
    let uid = null;
    let isHost = false;
    let cacheSpells = null;
    let timerInterval = null;
    let progressRAF = null;
    let lastSpellKey = null;
    const AFK_LIMIT_MS = 5 * 60 * 1000;
    let heartbeatInterval = null;
    let GAME_CACHE = null;

    let LAST_RANKS = {};
    let LAST_PHASE = null;

    // Local stats + history
    let STATS = loadStats();
    let HISTORY = []; // reset √† chaque partie

    // DOM helpers
    const el = (id)=>document.getElementById(id);

    // ---------- NEW: profil local + URL s√ªre ----------
    function loadLocalProfile() {
      try { return JSON.parse(localStorage.getItem('cdg_profile') || 'null'); }
      catch { return null; }
    }
    function saveLocalProfile(name, avatar) {
      try { localStorage.setItem('cdg_profile', JSON.stringify({ name, avatar })); } catch {}
    }
    function safeUrl(u) {
      try {
        const url = new URL(u, location.origin);
        return (url.protocol === 'https:' || url.protocol === 'http:') ? url.href : '';
      } catch { return ''; }
    }

    // Auth
    onAuthStateChanged(auth, (u) => { if (u) uid = u.uid; });
    async function ensureAuth() {
      if (auth.currentUser) { uid = auth.currentUser.uid; return uid; }
      const cred = await signInAnonymously(auth);
      uid = cred.user.uid;
      return uid;
    }

    // ---------- NEW: init welcome (pr√©-remplissage + preview + quick join) ----------
    (function initWelcomeForm() {
      const saved = loadLocalProfile();
      const nameInput = el('nameInput');
      const avatarSelect = el('avatarSelect');
      const avatarPreview = el('avatarPreview');
      const quickBtn = el('quickJoinBtn');

      if (saved?.avatar) avatarSelect.value = saved.avatar;
      avatarPreview.src = safeUrl(avatarSelect.value);

      if (saved?.name) {
        nameInput.value = saved.name;
        quickBtn.classList.remove('hidden');
      }

      avatarSelect.addEventListener('change', () => {
        avatarPreview.src = safeUrl(avatarSelect.value);
      });

      quickBtn.addEventListener('click', async () => {
        const s = loadLocalProfile();
        if (!s?.name || !s?.avatar) return;
        await doJoin(s.name, s.avatar);
      });

      // Enter = cliquer sur rejoindre
      nameInput.addEventListener('keydown', (e) => {
        if (e.key === "Enter") el("joinBtn").click();
      });
    })();

    // Spells
    async function loadSpells() {
      if (cacheSpells) return cacheSpells;
      const res = await fetch("data/championFull.json");
      const data = await res.json();
      const arr = [];
      for (const key in data.data) {
        const champ = data.data[key];
        champ.spells.forEach((spell, i) => {
          const cd = Array.isArray(spell.cooldown) ? spell.cooldown[0] : spell.cooldown;
          arr.push({ champ: champ.name, key: ['Q','W','E','R'][i], cd: Number(cd), name: spell.name });
        });
      }
      cacheSpells = arr;
      return arr;
    }
    function randomSpell(spells) {
      let s;
      for (let tries=0; tries<5; tries++) {
        s = spells[Math.floor(Math.random()*spells.length)];
        const key = s.champ + "|" + s.key;
        if (key !== lastSpellKey) { lastSpellKey = key; break; }
      }
      return s;
    }

    // ---------- NEW: pr√©-lobby ‚Äî aper√ßu joueurs avant de rejoindre ----------
    const playersPreviewList = document.getElementById('playersPreview');
    onValue(playersRef, (snapshot) => {
      const data = snapshot.val() || {};
      const entries = Object.entries(data).sort((a,b)=> (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      playersPreviewList.innerHTML = entries.map(([id, p]) => `
        <div class="player-card">
          <img src="${safeUrl(p.avatar)}" class="avatar" alt="">
          <div><strong>${escapeHtml(p.name||"")}</strong></div>
          <div class="muted">Score : ${Number(p.score)||0}</div>
        </div>
      `).join('') || `<div class="muted">Personne pour l‚Äôinstant. Partage le lien üëÜ</div>`;
    });

    // ---------- NEW: logique join factoris√©e ----------
    async function doJoin(name, avatar) {
      try { await ensureAuth(); } catch (e) { el("joinError").textContent = "Auth KO"; return; }

      saveLocalProfile(name, avatar);

      const myRef = ref(db, `rooms/${ROOM_ID}/players/${uid}`);
      await set(myRef, { name, avatar, score: 0, joinedAt: serverTimestamp(), lastSeen: serverTimestamp(), lastDelta: 0, lastAnswerValue: null, lastAnswerDiff: null });
      onDisconnect(myRef).remove();

      // Profil global (pour hebdo)
      try { await update(profilesRef(uid), { name, avatar, lastSeen: serverTimestamp() }); } catch(_) {}

      el("welcome").style.display = "none";
      el("game").style.display = "block";
      el("localRow").classList.remove('hidden');
      renderStatsChips();

      const stateSnap = await get(stateRef);
      const st = stateSnap.val();
      if (!st || !st.host) {
        isHost = true;
        await update(stateRef, { host: uid });
        el("settingsContainer").style.display = "block";
        el("startGameBtn").style.display = "inline-block";
        el("waitingHost").style.display = "none";
        el("status").textContent = "Vous √™tes l'h√¥te.";
      } else {
        isHost = (st.host === uid);
        if (!isHost) {
          el("waitingHost").style.display = "block";
          el("status").textContent = "En attente du lancement par l'h√¥te‚Ä¶";
        }
      }

      startHeartbeat();
    }

    // Join flow (bouton standard)
    el("joinBtn").addEventListener("click", async () => {
      const name = el("nameInput").value.trim().slice(0,24);
      const avatar = el("avatarSelect").value;
      if (!name) { el("joinError").textContent = "Pseudo requis"; return; }
      await doJoin(name, avatar);
    });

    function startHeartbeat(){
      const ping = async ()=> { try {
        await update(ref(db, `rooms/${ROOM_ID}/players/${uid}`), { lastSeen: serverTimestamp() });
        await update(profilesRef(uid), { lastSeen: serverTimestamp() });
      } catch(_){} };
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      heartbeatInterval = setInterval(ping, 30*1000);
      ['pointerdown','keydown','touchstart'].forEach(ev => document.addEventListener(ev, ping, { passive: true }));
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) ping(); });
      ping();
    }

    // Players list + leaderboard (room)
    const playersList = el("players");
    let renderLeaderboardLastPlayersSnapshot = null;

    onValue(playersRef, async (snapshot) => {
      const data = snapshot.val() || {};
      playersList.innerHTML = "";
      const entries = Object.entries(data).sort((a,b)=> (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      for (const [id, p] of entries) {
        const card = document.createElement("div");
        card.className = "player-card";
        card.innerHTML = `
          <img src="${safeUrl(p.avatar)}" class="avatar" alt="">
          <div><strong>${escapeHtml(p.name||"")}</strong></div>
          <div>Score : ${Number(p.score)||0}</div>`;
        playersList.appendChild(card);
      }
      await reassignHostIfNeeded(data);

      renderLeaderboardLastPlayersSnapshot = () => { renderLeaderboardFrom(data); if (GAME_CACHE?.phase === 'between') renderBetweenInfo(data); };
      if (GAME_CACHE && GAME_CACHE.phase === 'between') {
        renderLeaderboardFrom(data);
        renderBetweenInfo(data);
      }
    });

    async function reassignHostIfNeeded(playersObj) {
      const snap = await get(stateRef);
      const st = snap.val();
      if (!st || !st.host) return;
      if (!playersObj[st.host]) {
        const firstId = Object.keys(playersObj)[0];
        if (!firstId) { await set(stateRef, {}); return; }
        await update(stateRef, { host: firstId });
        if (firstId === uid) {
          isHost = true;
          el("settingsContainer").style.display = "block";
          el("startGameBtn").style.display = "inline-block";
          el("waitingHost").style.display = "none";
          el("status").textContent = "Vous √™tes devenu l'h√¥te.";
        }
      }
    }

    // Start game
    el("startGameBtn").addEventListener("click", async () => {
      if (!isHost) return alert("Seul l'h√¥te peut lancer la partie !");
      const totalTurns   = clampInt(el("nbTours").value, 1, 50);
      const turnDuration = clampInt(el("tempsTour").value, 5, 300);

      const spells = await loadSpells();
      const first = randomSpell(spells);

      await set(stateRef, {
        host: uid,
        settings: { totalTurns, turnDuration, delayBetween: DELAY_BETWEEN },
        turn: 1,
        phase: "answer",
        sort: first,
        tsStart: serverTimestamp(),
        top3: null
      });

      el("settingsContainer").style.display = "none";
      el("waitingHost").style.display = "none";
      clearPlayersDeltas();
      LAST_RANKS = {};
      LAST_PHASE = 'answer';
      HISTORY = []; // reset historique
      bumpLocalGames(); // nouvelle partie
    });

    // Submit answer (+ Enter)
    el("submitBtn").addEventListener("click", submitAnswer);
    el("answerInput").addEventListener("keydown", (e)=>{
      if (e.key === "Enter") submitAnswer();
    });
    async function submitAnswer() {
      const v = el("answerInput").value.trim();
      if (!/^\d{1,3}$/.test(v)) { el("feedback").textContent = "‚ö†Ô∏è Entrez un nombre (0‚Äì999)."; return; }
      const val = clampInt(v, 0, 999);
      const st = (await get(stateRef)).val();
      if (!st || st.phase !== "answer") { el("feedback").textContent = "Tour verrouill√©."; return; }
      await set(ref(db, `rooms/${ROOM_ID}/answers/${st.turn}/${uid}`), { value: val, at: serverTimestamp() });
      el("feedback").textContent = "‚úÖ R√©ponse enregistr√©e";
    }

    // State loop
    onValue(stateRef, (snap) => {
      const game = snap.val();
      if (!game || !game.settings) return;
      const prevPhase = LAST_PHASE;
      renderGame(game);
      setupTimer(game);

      // fade-in lors du changement
      if (prevPhase !== game.phase) {
        const toFade = [];
        if (game.phase === 'answer') toFade.push('answerSection');
        if (game.phase === 'between') { toFade.push('betweenInfo','leaderboardSection'); }
        toFade.forEach(id => { el(id).classList.add('fade-in'); setTimeout(()=>el(id).classList.remove('fade-in'), 280); });
      }

      if (game.phase === 'between') {
        setTimeout(async () => {
          const snapPlayers = await get(playersRef);
          const playersObj = snapPlayers.val() || {};
          renderLeaderboardFrom(playersObj);
          renderBetweenInfo(playersObj);
        }, 100);
      }
    });

    function renderGame(game) {
      LAST_PHASE = game.phase;
      GAME_CACHE = game;

      const { turn, settings, phase, sort, host } = game;
      const { totalTurns, delayBetween } = settings;
      if (turn > totalTurns) { finDePartie(host); return; }

      el("answerSection").classList.toggle("hidden", phase !== "answer");
      el("leaderboardSection").classList.toggle("hidden", phase !== "between");
      el("betweenInfo").classList.toggle("hidden", phase !== "between");

      el("sortDisplay").innerHTML = sort ? `<strong>${sort.champ} ${sort.key}</strong> ‚Äî ${sort.name}` : "";
      el("feedback").textContent = "";
      el("status").textContent = (phase === "answer")
        ? `Tour ${turn}/${totalTurns} ‚Äî R√©pondez !`
        : `Tour ${turn}/${totalTurns} termin√©. Prochain dans ${delayBetween}s‚Ä¶`;

      // autofocus phase "answer"
      if (phase === 'answer') {
        setTimeout(()=> { el('answerInput')?.focus(); el('answerInput')?.select?.(); }, 50);
      }

      el("restartRow").style.display = "none";
    }

    // Timer + barre ultra-smooth (sans bip) + avance de phase transactionnelle
    function setupTimer(game) {
      clearInterval(timerInterval);
      if (progressRAF) { cancelAnimationFrame(progressRAF); progressRAF = null; }

      const { settings, phase, tsStart } = game;
      const per = (phase === "answer") ? settings.turnDuration : settings.delayBetween;
      const bar = el('timerBar');
      const startedAt = Number(game.tsStart);

      if (!tsStart || !Number.isFinite(startedAt)) {
        el("timer").textContent = "";
        bar.style.transform = 'scaleX(0)';
        bar.classList.remove('danger');
        return;
      }

      // Chrono (texte), tick√© √† la seconde (l√©ger sur-√©chantillonnage)
      let lastShown = null;
      const secTick = () => {
        const now = Date.now();
        let left = per - Math.floor((now - startedAt)/1000);
        if (!Number.isFinite(left)) left = per;
        left = Math.max(0, Math.min(per, left));
        if (left !== lastShown) {
          el("timer").textContent = `${left}s`;
          lastShown = left;
        }
        if (left <= 0) {
          clearInterval(timerInterval);
          tryAdvancePhase(); // << avance phase (answer->between ou between->next)
        }
      };
      secTick();
      timerInterval = setInterval(secTick, 250);

      // Progress bar en ~60 FPS
      const loop = () => {
        const now = Date.now();
        const leftFloat = per - (now - startedAt)/1000;
        const clamped = Math.max(0, Math.min(per, leftFloat));
        const ratio = clamped / per || 0;

        bar.style.transform = `scaleX(${ratio})`;
        bar.classList.toggle('danger', clamped <= 3 + 1e-3);

        if (clamped > 0) {
          progressRAF = requestAnimationFrame(loop);
        } else {
          bar.style.transform = 'scaleX(0)';
        }
      };
      loop();
    }

    // -------- Avance de phase (lock transactionnel) --------
    async function tryAdvancePhase() {
      const lockRef = ref(db, `rooms/${ROOM_ID}/state/lock`);
      const now = Date.now();
      let gotLock = false;

      await runTransaction(lockRef, (cur) => {
        const expired = !cur || !cur.at || (now - Number(cur.at) > 8000); // lock 8s
        if (expired) return { by: uid || 'anon', at: now };
        return cur;
      }, { applyLocally: false }).then(res => {
        gotLock = res.committed && res.snapshot && res.snapshot.val() && Number(res.snapshot.val().at) === now;
      }).catch(()=>{});

      if (!gotLock) return;

      try {
        const stSnap = await get(stateRef);
        const st = stSnap.val();
        if (!st || !st.settings || !st.tsStart) return;

        const per = (st.phase === "answer") ? st.settings.turnDuration : st.settings.delayBetween;
        const startedAt = Number(st.tsStart);
        const left = per - Math.floor((Date.now() - startedAt)/1000);
        if (left > 0) return; // pas fini en r√©alit√© (lag)

        if (st.phase === "answer") {
          await closeAndScoreTurn();   // passe en between
        } else if (st.phase === "between") {
          await startNextTurn(st);     // tour suivant
        }
      } finally {
        try { await remove(lockRef); } catch(_) {}
      }
    }

    // -------- Scoring (Room) + Top3 badges + Global --------
    async function closeAndScoreTurn() {
      const stSnap = await get(stateRef);
      const game = stSnap.val();
      if (!game || !game.sort || !game.settings) return;

      const turn = game.turn;
      const answersSnap = await get(ref(db, `rooms/${ROOM_ID}/answers/${turn}`));
      const answers = answersSnap.val() || {};
      const correct = Number(game.sort.cd);

      const ops = [];
      const playersMap = (await get(playersRef)).val() || {};
      const podiumArray = [];

      const tsStartNum = Number(game.tsStart) || 0;

      for (const pid in answers) {
        const rep = Number(answers[pid].value);
        if (!Number.isFinite(rep)) continue;

        const at = Number(answers[pid].at) || 0;
        const diff = Math.abs(rep - correct);
        const pts = Math.max(0, 5000 - diff * 500);

        // 1) score de la room
        ops.push(incrementScore(pid, pts));

        // 2) delta affichage between + ms pour badges
        const answeredMs = (at && tsStartNum) ? Math.max(0, at - tsStartNum) : null;
        ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
          lastDelta: pts,
          lastAnswerValue: rep,
          lastAnswerDiff: diff,
          lastAnswerMs: answeredMs
        }));

        // 3) collecte top3 (+badges)
        const p = playersMap[pid] || {};
        const badges = [];
        if (diff === 0) badges.push('perfect');
        if (answeredMs != null && answeredMs < FAST_MS) badges.push('fast');
        if (diff <= 1 && diff > 0) badges.push('close');

        podiumArray.push({
          id: pid, name: p.name || "‚Äî",
          avatar: p.avatar || "https://api.dicebear.com/7.x/thumbs/svg?seed=Fox",
          value: rep, diff, points: pts,
          ms: answeredMs, badges
        });

        // 4) leaderboard global
        try { ops.push(incrementGlobal(pid, pts)); } catch (e) { console.error("incrementGlobal threw (sync):", e); }
      }

      // joueurs sans r√©ponse : reset deltas
      for (const pid in playersMap) {
        if (!answers[pid]) {
          ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
            lastDelta: 0,
            lastAnswerValue: null,
            lastAnswerDiff: null,
            lastAnswerMs: null
          }));
        }
      }
      await Promise.all(ops);

      // calcule et push le TOP3 (par diff croissant)
      podiumArray.sort((a,b)=> a.diff - b.diff || a.value - b.value);
      const top3 = podiumArray.slice(0, 3);

      await update(stateRef, { phase: "between", tsStart: serverTimestamp(), top3 });

      // rendu imm√©diat + mise √† jour stats locales/historique
      setTimeout(async () => {
        const snapshot = await get(playersRef);
        const playersObj = snapshot.val() || {};
        renderLeaderboardFrom(playersObj);
        renderBetweenInfo(playersObj);
        updateLocalStatsAndHistory(playersObj, game);
      }, 50);

      try { await remove(ref(db, `rooms/${ROOM_ID}/answers/${turn}`)); } catch(_) {}

      setTimeout(async () => {
        const p = (await get(playersRef)).val() || {};
        LAST_RANKS = computeRanksMap(p);
      }, 80);
    }

    function incrementScore(pid, delta) {
      const sref = ref(db, `rooms/${ROOM_ID}/players/${pid}/score`);
      return runTransaction(sref, (current) => (Number(current)||0) + delta);
    }

    async function incrementGlobal(pid, delta) {
      try {
        const playerNodeRef = ref(db, `rooms/${ROOM_ID}/players/${pid}`);
        const playerNodeSnap = await get(playerNodeRef);
        const playerNode = playerNodeSnap.val() || {};

        const profSnap = await get(profilesRef(pid));
        const prof = profSnap.val() || {};

        const name = playerNode.name || prof.name || "Invit√©";
        const avatar = playerNode.avatar || prof.avatar || "https://api.dicebear.com/7.x/thumbs/svg?seed=Fox";

        try { await update(profilesRef(pid), { name, avatar, lastSeen: serverTimestamp() }); } catch (e) {}

        try {
          await update(globalWeekRef(pid), { name, avatar });
          const weekScoreRef = ref(db, `leaderboards/weeks/${WEEK_ID}/${pid}/score`);
          await runTransaction(weekScoreRef, (current)=> (Number(current)||0) + delta);
        } catch (e) {}

        try {
          await update(globalSeasonRef(pid), { name, avatar });
          const seasonScoreRef = ref(db, `leaderboards/seasons/${SEASON_ID}/${pid}/score`);
          await runTransaction(seasonScoreRef, (current)=> (Number(current)||0) + delta);
        } catch (e) {}
      } catch (e) {
        console.error("incrementGlobal failed:", e?.code || e?.message || e);
      }
    }

    async function startNextTurn(prevGame) {
      const { turn, settings } = prevGame;
      if (turn >= settings.totalTurns) {
        await update(stateRef, { turn: settings.totalTurns + 1 });
        return;
      }
      await clearPlayersDeltas();

      const spells = await loadSpells();
      const next = randomSpell(spells);
      await set(stateRef, {
        host: prevGame.host,
        settings,
        turn: turn + 1,
        phase: "answer",
        sort: next,
        tsStart: serverTimestamp(),
        top3: null
      });
    }

    async function clearPlayersDeltas() {
      const players = (await get(playersRef)).val() || {};
      const ops = [];
      for (const pid in players) {
        ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
          lastDelta: 0,
          lastAnswerValue: null,
          lastAnswerDiff: null,
          lastAnswerMs: null
        }));
      }
      await Promise.all(ops);
    }

    // Leaderboard room (between)
    function computeSortedList(playersObj) {
      const list = Object.entries(playersObj || {}).map(([id,p]) => ({
        id, name: p.name || '‚Äî', avatar: p.avatar, score: Number(p.score)||0,
        lastDelta: Number(p.lastDelta)||0
      }));
      list.sort((a,b) => (b.score - a.score) || a.name.localeCompare(b.name));
      return list;
    }
    function computeRanksMap(playersObj) {
      const list = computeSortedList(playersObj);
      const map = {};
      list.forEach((p, idx) => map[p.id] = idx + 1);
      return map;
    }

    function renderLeaderboardFrom(playersObj) {
      const list = computeSortedList(playersObj);
      const showDelta = (GAME_CACHE && GAME_CACHE.phase === 'between');

      const rows = list.map((p, idx) => {
        const rank = idx + 1;
        const prev = LAST_RANKS[p.id];
        let posDelta = 0;
        if (prev != null) posDelta = prev - rank; // positif = mont√©e
        const arrow = posDelta > 0 ? `‚Üë${posDelta}` : posDelta < 0 ? `‚Üì${Math.abs(posDelta)}` : '‚Äì';
        const posCls = posDelta > 0 ? 'gain rise' : posDelta < 0 ? 'loss fall' : '';
        const podiumCls = rank<=3 ? ` lb-${rank} pulse` : '';
        const crown = rank === 1 ? 'üëë' : '';

        return `
          <div class="lb-row ${podiumCls} ${posCls}">
            <div class="lb-rank">${rank}</div>
            <img class="lb-avatar" src="${safeUrl(p.avatar)}" alt="">
            <div class="lb-name">${crown}${crown ? '&nbsp;' : ''}${escapeHtml(p.name)}</div>
            <div class="lb-score">${p.score}${showDelta && p.lastDelta ? `<span class="lb-delta">(+${p.lastDelta})</span>` : ''}<span class="lb-posdelta"> ${arrow}</span></div>
          </div>
        `;
      }).join('') || `<div class="muted">Aucun joueur pour le moment.</div>`;

      el('leaderboard').innerHTML = rows;
    }

    // Between info + TOP 3 (badges)
    function renderBetweenInfo(playersObj) {
      if (!GAME_CACHE || GAME_CACHE.phase !== 'between') { el('betweenInfo').innerHTML = ''; return; }
      const correct = GAME_CACHE?.sort?.cd;
      const me = playersObj?.[uid] || {};

      const myVal  = (me.lastAnswerValue != null && me.lastAnswerValue !== '') ? `${me.lastAnswerValue} sec` : '‚Äî';
      const myDiff = (me.lastAnswerDiff  != null && me.lastAnswerDiff  !== '') ? `${me.lastAnswerDiff} sec`  : '‚Äî';
      const myDeltaNum = (typeof me.lastDelta === 'number') ? me.lastDelta : 0;
      const myDeltaTxt = myDeltaNum > 0 ? `+${myDeltaNum}` : '+0';

      const top3 = Array.isArray(GAME_CACHE.top3) ? GAME_CACHE.top3 : [];

      const podiumHtml = top3.length
        ? `
        <div id="podium">
          ${top3.map((p, i)=> {
            const perfect = p.badges?.includes('perfect') ? ` <span class="badge b-perfect">üèÖ Perfect!</span>` : '';
            const fast    = p.badges?.includes('fast')    ? ` <span class="badge b-fast">‚ö° Rapid</span>` : '';
            const close   = p.badges?.includes('close')   ? ` <span class="badge b-close">üéØ Proche</span>` : '';
            const msTxt   = (typeof p.ms === 'number') ? ` ‚Äî ${(p.ms/1000).toFixed(2)}s` : '';
            return `
              <div class="podium-row">
                <div class="podium-rank">${i+1}</div>
                <img class="podium-avatar" src="${safeUrl(p.avatar)}" alt="">
                <div class="podium-name">${escapeHtml(p.name)}</div>
                <div class="podium-meta">${p.value}s (√©cart ${p.diff}s)${msTxt} ¬∑ +${p.points}${perfect}${fast}${close}</div>
              </div>
            `;
          }).join('')}
        </div>`
        : `<div class="muted" style="margin-top:6px;">Pas de podium ce tour.</div>`;

      el('betweenInfo').innerHTML = `
        <div><strong>‚úÖ R√©ponse correcte :</strong> ${correct} sec</div>
        <div class="muted" style="margin-top:6px;">
          <strong>Ta r√©ponse :</strong> ${myVal} &nbsp;|&nbsp; 
          <strong>√âcart :</strong> ${myDiff} &nbsp;|&nbsp; 
          <strong>Points :</strong> ${myDeltaTxt}
        </div>
        <h4 style="margin:10px 0 6px;">üèÖ Top 3 meilleures r√©ponses</h4>
        ${podiumHtml}
      `;
    }

    // Fin de partie + relance
    function finDePartie(hostId) {
      el("sortDisplay").innerHTML = "üéâ Fin de la partie !";
      el("answerSection").classList.add("hidden");
      el("status").textContent = "Merci d‚Äôavoir jou√© !";
      el("timer").textContent = "";
      el("leaderboardSection").classList.remove("hidden");
      get(playersRef).then(s => { 
        const obj = s.val() || {};
        renderLeaderboardFrom(obj);
        renderBetweenInfo(obj);
      });

      const showRestart = hostId === uid;
      el("restartRow").style.display = showRestart ? "block" : "none";
    }

    el("restartBtn").addEventListener("click", async () => {
      try {
        const resetScores = el("resetScores").checked;
        const st = (await get(stateRef)).val();
        if (!st || st.host !== uid) { alert("Seul l'h√¥te peut relancer la partie."); return; }

        if (resetScores) {
          const players = (await get(playersRef)).val() || {};
          const ops = Object.keys(players).map(pid =>
            update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), { score: 0 })
          );
          await Promise.all(ops);
        }

        const turnsSnap = await get(answersRef);
        const turns = turnsSnap.val() || {};
        await Promise.all(Object.keys(turns).map(t => remove(ref(db, `rooms/${ROOM_ID}/answers/${t}`))));
        await clearPlayersDeltas();

        const spells = await loadSpells();
        const first = randomSpell(spells);

        const totalTurns   = st.settings?.totalTurns   ?? 10;
        const turnDuration = st.settings?.turnDuration ?? 30;

        await set(stateRef, {
          host: st.host,
          settings: { totalTurns, turnDuration, delayBetween: DELAY_BETWEEN },
          turn: 1,
          phase: "answer",
          sort: first,
          tsStart: serverTimestamp(),
          top3: null
        });

        LAST_RANKS = {};
        LAST_PHASE = 'answer';
        HISTORY = []; // reset
        bumpLocalGames();

        el("restartRow").style.display = "none";
        el("waitingHost").style.display = "none";
      } catch (e) {
        console.error("Relance √©chou√©e:", e);
        alert("Relance impossible : " + (e?.code || e?.message || e));
      }
    });

    // Global leaderboard UI
    const globalModal = el('globalModal');
    el('openGlobalBtn').addEventListener('click', async (ev)=>{
      ev.preventDefault();
      el('weekLabel').textContent = WEEK_ID;
      globalModal.style.display = 'flex';
      await renderGlobalTop();
    });
    el('closeGlobal').addEventListener('click', ()=> globalModal.style.display = 'none');
    globalModal.addEventListener('click', (e)=>{ if (e.target === globalModal) globalModal.style.display = 'none'; });

    async function renderGlobalTop() {
      const qref = query(ref(db, `leaderboards/weeks/${WEEK_ID}`), orderByChild('score'), limitToLast(50));
      const snap = await get(qref);
      const data = snap.val() || {};
      const arr = Object.entries(data).map(([id, v]) => ({ id, name: v.name||'‚Äî', avatar: v.avatar, score: Number(v.score)||0 }));
      arr.sort((a,b)=> b.score - a.score);

      if (arr.length === 0) {
        el('globalList').innerHTML = `<div class="muted">Aucun score cette semaine pour l'instant. Joue un tour pour entrer au classement !</div>`;
        return;
      }

      const html = arr.map((p, i)=> `
        <div class="global-row">
          <div class="global-rank">${i+1}</div>
          <img class="lb-avatar" src="${safeUrl(p.avatar||'https://api.dicebear.com/7.x/thumbs/svg?seed=Fox')}" alt="">
          <div class="global-name">${escapeHtml(p.name)}</div>
          <div class="lb-score">${p.score}</div>
        </div>
      `).join('');
      el('globalList').innerHTML = html;
    }

    // Watchdog AFK host
    async function kickIfHostAFK() {
      const stSnap = await get(stateRef);
      const st = stSnap.val();
      if (!st || !st.host) return;

      const hostId = st.host;
      const hostNode = (await get(ref(db, `rooms/${ROOM_ID}/players/${hostId}`))).val();
      const lastSeen = hostNode?.lastSeen;
      if (!lastSeen) return;

      const stale = Date.now() - Number(lastSeen) > 5*60*1000;
      if (!stale) return;

      const players = (await get(playersRef)).val() || {};
      const candidates = Object.entries(players)
        .filter(([id,p]) => id !== hostId && p.lastSeen && (Date.now() - Number(p.lastSeen) <= 5*60*1000))
        .sort((a,b) => (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      if (!candidates.length) return;

      const newHostId = candidates[0][0];
      await runTransaction(ref(db, `rooms/${ROOM_ID}/state/host`), (current) => current === hostId ? newHostId : current);

      try { await remove(ref(db, `rooms/${ROOM_ID}/players/${hostId}`)); } catch(_) {}
    }
    setInterval(kickIfHostAFK, 30*1000);
    onValue(stateRef, () => { kickIfHostAFK(); });

    // -------- Stats locales + Historique --------
    document.getElementById('toggleHistory').addEventListener('click', ()=>{
      document.getElementById('historyWrap').classList.toggle('hidden');
      renderHistory();
    });

    function loadStats() {
      try { return JSON.parse(localStorage.getItem('cdg_stats_v1')) || { games:0, rounds:0, perfects:0, streak:0, bestStreak:0, sumDiff:0 }; }
      catch { return { games:0, rounds:0, perfects:0, streak:0, bestStreak:0, sumDiff:0 }; }
    }
    function saveStats() { localStorage.setItem('cdg_stats_v1', JSON.stringify(STATS)); }
    function renderStatsChips() {
      const avg = STATS.rounds ? (STATS.sumDiff / STATS.rounds) : 0;
      const pct = STATS.rounds ? Math.round((STATS.perfects / STATS.rounds) * 100) : 0;
      document.getElementById('chipGames').textContent  = `Parties: ${STATS.games}`;
      document.getElementById('chipRounds').textContent = `Tours jou√©s: ${STATS.rounds}`;
      document.getElementById('chipPerfect').textContent= `Perfects: ${STATS.perfects} (${pct}%)`;
      document.getElementById('chipAvg').textContent    = STATS.rounds ? `Diff moyen: ${avg.toFixed(2)}` : 'Diff moyen: ‚Äî';
      document.getElementById('chipStreak').textContent = `S√©rie perfect: ${STATS.streak} (best ${STATS.bestStreak})`;
    }
    function bumpLocalGames(){ STATS.games++; saveStats(); renderStatsChips(); }

    function updateLocalStatsAndHistory(playersObj, game) {
      const me = playersObj?.[uid] || {};
      if (me == null) return;

      // stats
      if (me.lastAnswerDiff != null) {
        STATS.rounds++;
        const d = Number(me.lastAnswerDiff) || 0;
        STATS.sumDiff += d;
        if (d === 0) {
          STATS.perfects++;
          STATS.streak++;
          STATS.bestStreak = Math.max(STATS.bestStreak, STATS.streak);
        } else {
          STATS.streak = 0;
        }
        saveStats();
        renderStatsChips();
      }

      // historique (local)
      const sort = game?.sort || {};
      const badges = [];
      if (me.lastAnswerDiff === 0) badges.push('perfect');
      if (typeof me.lastAnswerMs === 'number' && me.lastAnswerMs < FAST_MS) badges.push('fast');
      if (me.lastAnswerDiff > 0 && me.lastAnswerDiff <= 1) badges.push('close');

      HISTORY.push({
        champ: sort.champ, key: sort.key, name: sort.name,
        correct: sort.cd,
        value: me.lastAnswerValue,
        diff: me.lastAnswerDiff,
        points: me.lastDelta,
        ms: me.lastAnswerMs,
        badges
      });
      renderHistory();
    }

    function renderHistory() {
      const list = document.getElementById('historyList');
      if (!HISTORY.length) { list.innerHTML = `<div class="muted">Aucun tour pour l‚Äôinstant.</div>`; return; }
      list.innerHTML = HISTORY.map(h => {
        const perfect = h.badges.includes('perfect') ? ` <span class="badge b-perfect">üèÖ Perfect!</span>` : '';
        const fast    = h.badges.includes('fast')    ? ` <span class="badge b-fast">‚ö° Rapid</span>` : '';
        const close   = h.badges.includes('close')   ? ` <span class="badge b-close">üéØ Proche</span>` : '';
        const msTxt   = (typeof h.ms === 'number') ? ` ‚Äî ${(h.ms/1000).toFixed(2)}s` : '';
        return `
          <div class="hrow">
            <div style="min-width:120px"><strong>${escapeHtml(h.champ||'?')} ${h.key||''}</strong></div>
            <div style="flex:1; opacity:.9;">${escapeHtml(h.name||'')}</div>
            <div><strong>${h.value ?? '‚Äî'}</strong> / ${h.correct} (√©cart ${h.diff ?? '‚Äî'})${msTxt} ¬∑ +${h.points ?? 0}${perfect}${fast}${close}</div>
          </div>
        `;
      }).join('');
    }

    // Utils
    function clampInt(val, min, max) {
      const n = parseInt(val, 10);
      if (isNaN(n)) return min;
      return Math.max(min, Math.min(max, n));
    }
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;"," >":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    }

    window.addEventListener("beforeunload", ()=> {
      if (timerInterval) clearInterval(timerInterval);
      if (progressRAF) cancelAnimationFrame(progressRAF);
      if (heartbeatInterval) clearInterval(heartbeatInterval);
    });
  </script>
</body>
</html>
