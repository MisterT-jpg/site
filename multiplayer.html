<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cooldown Multiplayer (Rooms)</title>
  <style>
    body { font-family: Montserrat, system-ui, -apple-system, sans-serif; background:#1e3c72; color:#fff; padding:30px; text-align:center; transition: background-color .15s ease; }
    input, button, select { font-size:1rem; padding:10px; margin:10px; border-radius:6px; border:none; }
    button { cursor:pointer }
    a.btn { text-decoration:none; background:#ffd700; color:#222; font-weight:700; padding:8px 12px; border-radius:8px; }
    #topRight { position:fixed; top:12px; right:12px; display:flex; gap:8px; z-index:10; }
    #game, #settingsContainer, #waitingHost { display:none; }
    #startGameBtn { display:none; }
    .player-grid { display:flex; justify-content:center; gap:16px; flex-wrap:wrap; margin:20px 0; }
    .player-card { background-color:rgba(255,255,255,0.1); padding:10px; border-radius:8px; min-width:140px; }
    .avatar { width:40px; height:40px; border-radius:50%; object-fit:cover; margin-bottom:5px; background:#fff; }
    #feedback { font-size:0.95rem; margin-top:8px; color:#90ee90; min-height:1.2em; }
    #status { opacity:.85; font-size:.95rem; min-height:1.2em; }
    .hidden { display:none }
    .muted { opacity:.75 }

    /* Timer progress bar (ultra-smooth) */
    #timerBarWrap { height:10px; background:rgba(255,255,255,0.15); border-radius:999px; overflow:hidden; max-width:520px; margin:6px auto 0; }
    #timerBar {
      height:100%;
      width:100%;
      background:linear-gradient(90deg,#22c55e,#3b82f6);
      transform-origin:left center;
      transform:scaleX(1);
      transition: background .2s;
      will-change: transform;
    }
    #timerBar.danger { background:#ef4444; }

    /* Fade-in transitions */
    .fade-in { animation: fadeIn .25s ease both; }
    @keyframes fadeIn { from { opacity:0; transform:translateY(6px); } to { opacity:1; transform:translateY(0); } }

    /* Leaderboard */
    #leaderboardSection { margin-top:18px; }
    .lb-row { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.08); margin:8px 0; will-change: transform; }
    .lb-rank { width:34px; text-align:center; font-weight:800; }
    .lb-avatar { width:32px; height:32px; border-radius:50%; background:#fff; object-fit:cover; }
    .lb-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center; gap:6px; }
    .lb-score { font-weight:800; }
    .lb-delta { font-weight:800; margin-left:8px; }
    .lb-posdelta { font-weight:700; margin-left:8px; }
    .lb-1 { background:linear-gradient(90deg, rgba(255,215,0,.22), transparent); }
    .lb-2 { background:linear-gradient(90deg, rgba(192,192,192,.22), transparent); }
    .lb-3 { background:linear-gradient(90deg, rgba(205,127,50,.22), transparent); }

    .gain { background-color: rgba(76,175,80,0.18); }
    .loss { background-color: rgba(244,67,54,0.18); }
    .pulse { animation: pulse 0.9s ease-out 1; }
    .rise  { animation: rise 0.45s ease-out 1; }
    .fall  { animation: fall 0.45s ease-out 1; }
    @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.03)} 100%{transform:scale(1)} }
    @keyframes rise  { 0%{transform:translateY(6px)} 100%{transform:translateY(0)} }
    @keyframes fall  { 0%{transform:translateY(-6px)} 100%{transform:translateY(0)} }

    /* LIVE badge + my rank chip */
    .badge-live { display:inline-block; padding:2px 8px; border-radius:999px; font-weight:800; font-size:.8rem; background:#ffed4a; color:#3a2a00; margin-left:8px; }
    #myLiveRank { display:inline-flex; align-items:center; gap:6px; margin-top:8px; }

    /* Crown animation */
    .crown {
      display:inline-flex; align-items:center; justify-content:center;
      width:20px; height:20px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #ffe47a, #e6b400 60%, #7a5b00 100%);
      box-shadow: 0 0 10px rgba(255,215,0,.6), 0 0 20px rgba(255,215,0,.25);
      animation: crownPulse 1.5s ease-in-out infinite;
    }
    @keyframes crownPulse {
      0% { transform: translateY(0) scale(1); box-shadow:0 0 10px rgba(255,215,0,.6),0 0 20px rgba(255,215,0,.25); }
      50%{ transform: translateY(-1px) scale(1.06); box-shadow:0 0 12px rgba(255,215,0,.9),0 0 24px rgba(255,215,0,.35); }
      100%{ transform: translateY(0) scale(1); }
    }
    .crown:before {
      content: "üëë"; font-size:14px; filter: drop-shadow(0 0 2px rgba(0,0,0,.3));
    }

    /* Teaser & flash (d√©j√† pack 3) */
    .teaser-sort { filter: blur(3px) brightness(.9); opacity:.75; }
    .flash-layer {
      position: fixed; inset: 0; pointer-events: none;
      background: radial-gradient(1200px 600px at 50% 40%, rgba(0,0,0,.28), rgba(0,0,0,0) 60%);
      opacity: 0; transition: opacity .18s ease; z-index: 5;
    }
    .flash-layer.show { opacity: 1; }

    /* Pack 2 */
    .input-valid   { box-shadow: 0 0 0 2px rgba(34,197,94,.9) inset; }
    .input-invalid { box-shadow: 0 0 0 2px rgba(239,68,68,.9) inset; }
    @keyframes shakeX { 0%{transform:translateX(0)}20%{transform:translateX(-6px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}100%{transform:translateX(0)} }
    .shake { animation: shakeX .32s ease; }
    .answer-burst { font-size: clamp(1.8rem, 4vw, 2.6rem); font-weight: 900; line-height: 1.2; margin: 6px auto 2px; display: inline-block; padding: 4px 10px; border-radius: 12px; background: linear-gradient(90deg, rgba(34,197,94,.18), rgba(59,130,246,.18)); }
    @keyframes popIn { from{transform:scale(.92); opacity:0} 60%{transform:scale(1.04); opacity:1} to{transform:scale(1)} }
    .pop-in { animation: popIn .35s ease-out both; }

    /* Pack 3 */
    .timer-final { color:#dc2626; animation: pulseTimer .6s ease-in-out infinite; }
    @keyframes pulseTimer { 0%{transform:scale(1)} 50%{transform:scale(1.15)} 100%{transform:scale(1)} }
    .fade-slide { animation: fadeSlide .35s ease both; }
    @keyframes fadeSlide { from { opacity:0; transform:translateY(10px);} to { opacity:1; transform:translateY(0);} }
  </style>
</head>
<body>
  <div id="flashLayer" class="flash-layer"></div>

  <div id="topRight">
    <a href="index.html" class="btn" title="Aller au mode Solo">üè† Solo</a>
    <a id="shareBtn" class="btn" href="#" title="Copier le lien du salon">üîó Lien du salon</a>
    <a id="openGlobalBtn" class="btn" href="#" title="Classement hebdo global">üèÜ Hebdo</a>
  </div>

  <div id="welcome">
    <h1>Multiplayer Cooldown Trainer</h1>
    <div id="roomInfo" class="muted" style="margin-bottom:8px;"></div>
    <input id="nameInput" placeholder="Ton pseudo..." maxlength="24"/>
    <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin-top:6px;">
      <select id="avatarSelect" title="Avatar">
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Fox">ü¶ä Avatar 1</option>
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Cat">üê± Avatar 2</option>
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Robot">ü§ñ Avatar 3</option>
        <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Dragon">üêâ Avatar 4</option>
      </select>
      <img id="avatarPreview" class="avatar" alt="aper√ßu avatar" />
    </div>
    <button id="joinBtn">Rejoindre</button>
    <button id="quickJoinBtn" class="hidden">‚ö° Rejoindre en un clic</button>
    <div id="joinError" class="muted"></div>

    <div id="preLobby" style="margin-top:18px;">
      <h3 style="margin:8px 0;">Joueurs dans ce salon</h3>
      <div id="playersPreview" class="player-grid"></div>
    </div>
  </div>

  <div id="settingsContainer">
    <h3>Param√©trer la partie</h3>
    <label>Nombre de tours:
      <input type="number" id="nbTours" value="10" min="1" max="50">
    </label>
    <label>Temps par tour (s):
      <input type="number" id="tempsTour" value="30" min="5" max="300">
    </label>
    <div class="muted">Pause entre tours : 10s</div>
    <br>
    <button id="startGameBtn">üéÆ Lancer la partie</button>
  </div>

  <div id="waitingHost">
    <p>‚è≥ En attente que l'h√¥te lance la partie...</p>
  </div>

  <div id="game">
    <div id="status" class="muted"></div>
    <div id="myLiveRank" class="chip hidden">Mon rang : ‚Äî</div>

    <h2>Joueurs connect√©s</h2>
    <div class="player-grid" id="players"></div>

    <div id="sortDisplay" style="margin-top:16px;font-size:1.2rem;min-height:1.8em;"></div>

    <div id="timer" style="font-size:1.6rem;margin:10px 0;min-height:1.6em;"></div>
    <div id="timerBarWrap"><div id="timerBar"></div></div>

    <div id="answerSection" class="hidden">
      <input id="answerInput" placeholder="Cooldown en sec" inputmode="numeric" pattern="[0-9]*" maxlength="3">
      <button id="submitBtn">Envoyer</button>
      <div id="feedback"></div>
    </div>

    <div id="betweenInfo" class="hidden"></div>

    <div id="leaderboardSection">
      <h3 id="lbTitle" style="margin:8px 0;">Classement</h3>
      <div id="leaderboard" style="max-width:560px;margin:0 auto;text-align:left; position:relative;"></div>
    </div>

    <div id="restartRow" style="margin-top:14px; display:none">
      <label style="font-size:.95rem">
        <input type="checkbox" id="resetScores" checked>
        R√©initialiser les scores
      </label>
      <button id="restartBtn">üîÅ Relancer la partie</button>
    </div>

    <div id="localRow" class="hidden">
      <span class="chip" id="chipGames">Parties: 0</span>
      <span class="chip" id="chipRounds">Tours jou√©s: 0</span>
      <span class="chip" id="chipPerfect">Perfects: 0 (0%)</span>
      <span class="chip" id="chipAvg">Diff moyen: ‚Äî</span>
      <span class="chip" id="chipStreak">S√©rie perfect: 0</span>
      <button id="toggleHistory" class="btn">üìù Historique</button>
    </div>
    <div id="historyWrap" class="hidden">
      <div id="historyList"></div>
    </div>
  </div>

  <div id="globalModal" class="modal-backdrop">
    <div class="modal">
      <button id="closeGlobal" class="close-btn">Fermer</button>
      <h3>üèÜ Classement hebdo ‚Äî <span id="weekLabel"></span></h3>
      <div class="week-note">R√©initialisation chaque lundi √† 00:00 (UTC).</div>
      <div id="globalList" style="margin-top:10px;"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, set, onValue, onDisconnect, update, get, remove,
      serverTimestamp, runTransaction, query, orderByChild, limitToLast
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    console.log('Firebase SDK charg√© ? app=', !!initializeApp);

    const firebaseConfig = {
      apiKey: "AIzaSyBjkxLbnCBZYvcyNRrGxwphT6nCyPOcGfI",
      authDomain: "cdguesser.firebaseapp.com",
      projectId: "cdguesser",
      storageBucket: "cdguesser.appspot.com",
      messagingSenderId: "1094034546231",
      appId: "1:1094034546231:web:1baaeca8470b211cf529b2",
      databaseURL: "https://cdguesser-default-rtdb.europe-west1.firebasedatabase.app"
    };
    const app  = initializeApp(firebaseConfig);
    const db   = getDatabase(app);
    const auth = getAuth(app);

    const DELAY_BETWEEN = 10;
    const SEASON_ID = "S1";
    const FAST_MS = 3000;

    function getRoomId() {
      const url = new URL(window.location.href);
      let id = url.searchParams.get('room');
      if (!/^[a-z0-9]{2,20}$/i.test(id || '')) {
        id = Math.random().toString(36).slice(2, 8);
        url.searchParams.set('room', id);
        history.replaceState(null, '', url.toString());
      }
      return id;
    }
    const ROOM_ID = getRoomId();
    const playersRef  = ref(db, `rooms/${ROOM_ID}/players`);
    const stateRef    = ref(db, `rooms/${ROOM_ID}/state`);
    const answersRef  = ref(db, `rooms/${ROOM_ID}/answers`);

    function getISOWeekKey(d=new Date()) {
      const date = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
      const dayNum = (date.getUTCDay() + 6) % 7;
      date.setUTCDate(date.getUTCDate() - dayNum + 3);
      const firstThu = new Date(Date.UTC(date.getUTCFullYear(),0,4));
      const week = 1 + Math.round(((date - firstThu)/86400000 - 3 + ((firstThu.getUTCDay()+6)%7)) / 7);
      const year = date.getUTCFullYear();
      return `${year}-W${String(week).padStart(2,'0')}`;
    }
    const WEEK_ID = getISOWeekKey();

    function globalWeekRef(uid) { return ref(db, `leaderboards/weeks/${WEEK_ID}/${uid}`); }
    function globalSeasonRef(uid){ return ref(db, `leaderboards/seasons/${SEASON_ID}/${uid}`); }
    const profilesRef = (uid)=> ref(db, `profiles/${uid}`);

    const shareBtn = document.getElementById('shareBtn');
    document.getElementById('roomInfo').textContent = `Salon : ${ROOM_ID}`;
    shareBtn.href = window.location.href;
    shareBtn.onclick = async (e) => {
      e.preventDefault();
      try { await navigator.clipboard.writeText(window.location.href); shareBtn.textContent = '‚úÖ Lien copi√©'; setTimeout(()=>shareBtn.textContent='üîó Lien du salon',1500);} catch(_) {}
    };

    let uid = null;
    let isHost = false;
    let cacheSpells = null;
    let timerInterval = null;
    let progressRAF = null;
    let lastSpellKey = null;
    let heartbeatInterval = null;
    let GAME_CACHE = null;
    let NEXT_SORT_LOCAL = null;
    let LAST_RANKS = {};
    let LAST_PHASE = null;
    let GAME_OVER = false;
    let STATS = loadStats();
    let HISTORY = [];
    let LATEST_PLAYERS = {};

    const el = (id)=>document.getElementById(id);
    const flashLayer = document.getElementById('flashLayer');

    onAuthStateChanged(auth, (u) => { if (u) uid = u.uid; });
    async function ensureAuth() {
      if (auth.currentUser) { uid = auth.currentUser.uid; return uid; }
      const cred = await signInAnonymously(auth);
      uid = cred.user.uid;
      return uid;
    }

    function loadLocalProfile() { try { return JSON.parse(localStorage.getItem('cdg_profile') || 'null'); } catch { return null; } }
    function saveLocalProfile(name, avatar) { try { localStorage.setItem('cdg_profile', JSON.stringify({ name, avatar })); } catch {} }
    function safeUrl(u) { try { const url = new URL(u, location.origin); return (url.protocol === 'https:' || url.protocol === 'http:') ? url.href : ''; } catch { return ''; } }

    (function initWelcomeForm() {
      const saved = loadLocalProfile();
      const nameInput = el('nameInput');
      const avatarSelect = el('avatarSelect');
      const avatarPreview = el('avatarPreview');
      const quickBtn = el('quickJoinBtn');

      if (saved?.avatar) avatarSelect.value = saved.avatar;
      avatarPreview.src = safeUrl(avatarSelect.value);

      if (saved?.name) {
        nameInput.value = saved.name;
        quickBtn.classList.remove('hidden');
      }

      avatarSelect.addEventListener('change', () => avatarPreview.src = safeUrl(avatarSelect.value));
      quickBtn.addEventListener('click', async () => {
        const s = loadLocalProfile();
        if (!s?.name || !s?.avatar) return;
        await doJoin(s.name, s.avatar);
      });
      nameInput.addEventListener('keydown', (e) => { if (e.key === "Enter") el("joinBtn").click(); });
    })();

    async function loadSpells() {
      if (cacheSpells) return cacheSpells;
      const res = await fetch("data/championFull.json");
      const data = await res.json();
      const arr = [];
      for (const key in data.data) {
        const champ = data.data[key];
        champ.spells.forEach((spell, i) => {
          const cd = Array.isArray(spell.cooldown) ? spell.cooldown[0] : spell.cooldown;
          arr.push({ champ: champ.name, key: ['Q','W','E','R'][i], cd: Number(cd), name: spell.name });
        });
      }
      cacheSpells = arr;
      return arr;
    }
    function randomSpell(spells) {
      let s;
      for (let tries=0; tries<5; tries++) {
        s = spells[Math.floor(Math.random()*spells.length)];
        const key = s.champ + "|" + s.key;
        if (key !== lastSpellKey) { lastSpellKey = key; break; }
      }
      return s;
    }

    const playersPreviewList = document.getElementById('playersPreview');
    onValue(playersRef, (snapshot) => {
      const data = snapshot.val() || {};
      const entries = Object.entries(data).sort((a,b)=> (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      playersPreviewList.innerHTML = entries.map(([id, p]) => `
        <div class="player-card">
          <img src="${safeUrl(p.avatar)}" class="avatar" alt="">
          <div><strong>${escapeHtml(p.name||"")}</strong></div>
          <div class="muted">Score : ${Number(p.score)||0}</div>
        </div>
      `).join('') || `<div class="muted">Personne pour l‚Äôinstant. Partage le lien üëÜ</div>`;
    });

    async function doJoin(name, avatar) {
      try { await ensureAuth(); }
      catch (e) { el("joinError").textContent = "‚ùå Auth KO : " + (e?.message || e); throw e; }

      try {
        saveLocalProfile(name, avatar);
        const myRef = ref(db, `rooms/${ROOM_ID}/players/${uid}`);
        await set(myRef, { name, avatar, score: 0, joinedAt: serverTimestamp(), lastSeen: serverTimestamp(), lastDelta: 0, lastAnswerValue: null, lastAnswerDiff: null });
        onDisconnect(myRef).remove();
        try { await update(profilesRef(uid), { name, avatar, lastSeen: serverTimestamp() }); } catch(_) {}

        el("welcome").style.display = "none";
        el("game").style.display = "block";
        el("localRow").classList.remove('hidden');
        renderStatsChips();

        const stateSnap = await get(stateRef);
        const st = stateSnap.val();
        if (!st || !st.host) {
          isHost = true;
          await update(stateRef, { host: uid });
          el("settingsContainer").style.display = "block";
          el("startGameBtn").style.display = "inline-block";
          el("waitingHost").style.display = "none";
          el("status").textContent = "Vous √™tes l'h√¥te.";
        } else {
          isHost = (st.host === uid);
          if (!isHost) { el("waitingHost").style.display = "block"; el("status").textContent = "En attente du lancement par l'h√¥te‚Ä¶"; }
        }
        startHeartbeat();
      } catch (e) {
        el("joinError").textContent = "‚ùå Erreur r√©seau/base : " + (e?.message || e);
        throw e;
      }
    }

    const playersList = el("players");
    let renderLeaderboardLastPlayersSnapshot = null;

    onValue(playersRef, async (snapshot) => {
      const data = snapshot.val() || {};
      LATEST_PLAYERS = data;
      playersList.innerHTML = "";
      const entries = Object.entries(data).sort((a,b)=> (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      for (const [id, p] of entries) {
        const card = document.createElement("div");
        card.className = "player-card";
        card.innerHTML = `
          <img src="${safeUrl(p.avatar)}" class="avatar" alt="">
          <div><strong>${escapeHtml(p.name||"")}</strong></div>
          <div>Score : ${Number(p.score)||0}</div>`;
        playersList.appendChild(card);
      }
      await reassignHostIfNeeded(data);

      renderLeaderboardLastPlayersSnapshot = () => { 
        if (!GAME_OVER) {
          renderLeaderboardFrom(data);
          updateLiveRankChip(data);
          if (GAME_CACHE?.phase === 'between') renderBetweenInfo(data);
        }
      };
      if (!GAME_OVER) {
        renderLeaderboardFrom(data);
        updateLiveRankChip(data);
        if (GAME_CACHE?.phase === 'between') renderBetweenInfo(data);
      }
    });

    async function reassignHostIfNeeded(playersObj) {
      const snap = await get(stateRef);
      const st = snap.val();
      if (!st || !st.host) return;
      if (!playersObj[st.host]) {
        const firstId = Object.keys(playersObj)[0];
        if (!firstId) { await set(stateRef, {}); return; }
        await update(stateRef, { host: firstId });
        if (firstId === uid) {
          isHost = true;
          el("settingsContainer").style.display = "block";
          el("startGameBtn").style.display = "inline-block";
          el("waitingHost").style.display = "none";
          el("status").textContent = "Vous √™tes devenu l'h√¥te.";
        }
      }
    }

    el("startGameBtn").addEventListener("click", async () => {
      if (!isHost) return alert("Seul l'h√¥te peut lancer la partie !");
      const totalTurns   = clampInt(el("nbTours").value, 1, 50);
      const turnDuration = clampInt(el("tempsTour").value, 5, 300);

      const spells = await loadSpells();
      const first = randomSpell(spells);

      NEXT_SORT_LOCAL = null;
      GAME_OVER = false;

      await set(stateRef, {
        host: uid,
        settings: { totalTurns, turnDuration, delayBetween: DELAY_BETWEEN },
        turn: 1,
        phase: "answer",
        sort: first,
        tsStart: serverTimestamp(),
        top3: null
      });

      el("settingsContainer").style.display = "none";
      el("waitingHost").style.display = "none";
      clearPlayersDeltas();
      LAST_RANKS = {};
      LAST_PHASE = 'answer';
      HISTORY = [];
      bumpLocalGames();
    });

    (function bindJoin(){
      const btn = el('joinBtn');
      if (!btn) return;
      const onClick = async () => {
        const nameInput = el('nameInput');
        const avatarSel = el('avatarSelect');
        const name = (nameInput?.value || '').trim().slice(0,24);
        const avatar = avatarSel?.value || '';
        if (!name) { const err = el('joinError'); err.textContent = "‚ö†Ô∏è Pseudo requis"; nameInput?.classList.add('shake'); setTimeout(()=> nameInput?.classList.remove('shake'), 340); nameInput?.focus(); return; }
        btn.disabled = true; btn.textContent = "Connexion‚Ä¶";
        try { await doJoin(name, avatar); } 
        catch(e) { console.error('Join failed:', e); el('joinError').textContent = "‚ùå Impossible de rejoindre : " + (e?.message || e); btn.disabled = false; btn.textContent = "Rejoindre"; }
      };
      btn.addEventListener('click', onClick);
      btn.onclick = onClick;
    })();

    function startHeartbeat(){
      const ping = async ()=> { try {
        await update(ref(db, `rooms/${ROOM_ID}/players/${uid}`), { lastSeen: serverTimestamp() });
        await update(profilesRef(uid), { lastSeen: serverTimestamp() });
      } catch(_){} };
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      heartbeatInterval = setInterval(ping, 30*1000);
      ['pointerdown','keydown','touchstart'].forEach(ev => document.addEventListener(ev, ping, { passive: true }));
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) ping(); });
      ping();
    }

    el("submitBtn").addEventListener("click", submitAnswer);
    el("answerInput").addEventListener("keydown", (e)=>{ if (e.key === "Enter") submitAnswer(); });

    function isValidAnswerValue(v) { return /^\d{1,3}$/.test(v) && Number(v) >= 0 && Number(v) <= 999; }
    function applyInputFeedback() {
      const input = el("answerInput");
      const v = (input.value || "").trim();
      input.classList.remove("input-valid", "input-invalid");
      if (!v) return;
      if (isValidAnswerValue(v)) input.classList.add("input-valid");
      else input.classList.add("input-invalid");
    }
    el("answerInput").addEventListener("input", applyInputFeedback);
    el("answerInput").addEventListener("blur", applyInputFeedback);

    async function submitAnswer() {
      const input = el("answerInput");
      const vRaw = input.value.trim();
      const valid = isValidAnswerValue(vRaw);
      if (!valid) {
        el("feedback").textContent = "‚ö†Ô∏è Entrez un nombre (0‚Äì999).";
        input.classList.remove("input-valid");
        input.classList.add("input-invalid", "shake");
        setTimeout(()=> input.classList.remove("shake"), 340);
        input.focus();
        return;
      }

      const val = clampInt(vRaw, 0, 999);
      const st = (await get(stateRef)).val();
      if (!st || st.phase !== "answer") { el("feedback").textContent = "Tour verrouill√©."; return; }
      await set(ref(db, `rooms/${ROOM_ID}/answers/${st.turn}/${uid}`), { value: val, at: serverTimestamp() });

      el("feedback").textContent = "‚úÖ R√©ponse enregistr√©e";
      input.classList.remove("input-invalid");
      input.classList.add("input-valid");
      setTimeout(() => { if (GAME_CACHE?.phase === 'answer') el("feedback").textContent = ""; }, 1200);
    }

    onValue(answersRef, (snap)=>{
      const all = snap.val() || {};
      const turn = GAME_CACHE?.turn;
      if (!turn || GAME_CACHE?.phase !== 'answer') return;
      const current = all[turn] || {};
      const answeredCount = Object.keys(current).length;
      const playersCount  = Object.keys(LATEST_PLAYERS||{}).length;
      if (playersCount > 0 && answeredCount >= playersCount && isHost) {
        tryAdvancePhase();
      }
    });

    onValue(stateRef, (snap) => {
      const game = snap.val();
      if (!game || !game.settings) return;

      const prevPhase = LAST_PHASE;
      renderGame(game, prevPhase);
      setupTimer(game);

      if (prevPhase !== game.phase) {
        const gameEl = el('game');
        gameEl.classList.remove('fade-slide');
        void gameEl.offsetWidth;
        gameEl.classList.add('fade-slide');
      }

      if (!GAME_OVER && game.phase === 'between') {
        setTimeout(async () => {
          const snapPlayers = await get(playersRef);
          const playersObj = snapPlayers.val() || {};
          renderLeaderboardFrom(playersObj);
          updateLiveRankChip(playersObj);
          renderBetweenInfo(playersObj);
        }, 100);
      }
    });

    function renderGame(game, prevPhase) {
      LAST_PHASE = game.phase;
      GAME_CACHE = game;

      const { turn, settings, phase, sort, host } = game;
      const { totalTurns, delayBetween } = settings;
      if (turn > totalTurns) { finDePartie(host); return; }

      el("answerSection").classList.toggle("hidden", phase !== "answer");
      // Leaderboard ‚Üí TOUJOURS visible (live en answer)
      el("leaderboardSection").classList.remove("hidden");
      el("betweenInfo").classList.toggle("hidden", phase !== "between");

      el("lbTitle").innerHTML = phase === 'answer' ? `Classement <span class="badge-live">LIVE</span>` : `Classement`;
      el("sortDisplay").innerHTML = sort ? `<strong>${sort.champ} ${sort.key}</strong> ‚Äî ${sort.name}` : "";

      el("status").textContent = (phase === "answer")
        ? `Tour ${turn}/${totalTurns} ‚Äî R√©pondez !`
        : `Tour ${turn}/${totalTurns} termin√©. Prochain dans ${delayBetween}s‚Ä¶`;

      if (phase === 'answer') {
        el('myLiveRank').classList.remove('hidden');
      } else {
        el('myLiveRank').classList.add('hidden');
      }

      if (phase === 'answer' && prevPhase !== 'answer') {
        setTimeout(()=> { const inp = el('answerInput'); inp?.focus(); inp?.select?.(); }, 50);
        el('timer')?.classList?.remove('timer-final');
        if (flashLayer) flashLayer.classList.remove('show');
        el("feedback").textContent = "";
      }

      el("restartRow").style.display = "none";
    }

    function setupTimer(game) {
      clearInterval(timerInterval);
      if (progressRAF) { cancelAnimationFrame(progressRAF); progressRAF = null; }
      const { settings, phase, tsStart } = game;
      const per = (phase === "answer") ? settings.turnDuration : settings.delayBetween;
      const bar = el('timerBar');
      const timerText = el('timer');
      const startedAt = Number(game.tsStart);

      if (!tsStart || !Number.isFinite(startedAt)) {
        timerText.textContent = "";
        bar.style.transform = 'scaleX(0)';
        bar.classList.remove('danger');
        timerText.classList.remove('timer-final');
        if (flashLayer) flashLayer.classList.remove('show');
        return;
      }

      let lastShown = null;
      const secTick = () => {
        const now = Date.now();
        let left = per - Math.floor((now - startedAt)/1000);
        if (!Number.isFinite(left)) left = per;
        left = Math.max(0, Math.min(per, left));

        if (left !== lastShown) { timerText.textContent = `${left}s`; lastShown = left; }

        const finalPhase = left <= 3 && left > 0;
        timerText.classList.toggle('timer-final', finalPhase);
        bar.classList.toggle('danger', left <= 3 + 1e-3);
        if (flashLayer) flashLayer.classList.toggle('show', finalPhase);

        if (left <= 0) {
          clearInterval(timerInterval);
          timerText.classList.remove('timer-final');
          if (flashLayer) flashLayer.classList.remove('show');
          tryAdvancePhase();
        }
      };
      secTick();
      timerInterval = setInterval(secTick, 250);

      const loop = () => {
        const now = Date.now();
        const leftFloat = per - (now - startedAt)/1000;
        const clamped = Math.max(0, Math.min(per, leftFloat));
        const ratio = clamped / per || 0;
        bar.style.transform = `scaleX(${ratio})`;
        if (clamped > 0) progressRAF = requestAnimationFrame(loop);
        else bar.style.transform = 'scaleX(0)';
      };
      loop();
    }

    async function tryAdvancePhase() {
      const lockRef = ref(db, `rooms/${ROOM_ID}/state/lock`);
      const now = Date.now();
      let gotLock = false;

      await runTransaction(lockRef, (cur) => {
        const expired = !cur || !cur.at || (now - Number(cur.at) > 8000);
        if (expired) return { by: uid || 'anon', at: now };
        return cur;
      }, { applyLocally: false }).then(res => {
        gotLock = res.committed && res.snapshot && res.snapshot.val() && Number(res.snapshot.val().at) === now;
      }).catch(()=>{});

      if (!gotLock) return;

      try {
        const stSnap = await get(stateRef);
        const st = stSnap.val();
        if (!st || !st.settings || !st.tsStart) return;

        const per = (st.phase === "answer") ? st.settings.turnDuration : st.settings.delayBetween;
        const startedAt = Number(st.tsStart);
        const left = per - Math.floor((Date.now() - startedAt)/1000);
        if (left > 0) return;

        if (st.phase === "answer") {
          await closeAndScoreTurn();
        } else if (st.phase === "between") {
          await startNextTurn(st);
        }
      } finally {
        try { await remove(lockRef); } catch(_) {}
      }
    }

    async function closeAndScoreTurn() {
      const stSnap = await get(stateRef);
      const game = stSnap.val();
      if (!game || !game.sort || !game.settings) return;

      const turn = game.turn;
      const answersSnap = await get(ref(db, `rooms/${ROOM_ID}/answers/${turn}`));
      const answers = answersSnap.val() || {};
      const correct = Number(game.sort.cd);

      const ops = [];
      const playersMap = (await get(playersRef)).val() || {};
      const podiumArray = [];
      const tsStartNum = Number(game.tsStart) || 0;

      for (const pid in answers) {
        const rep = Number(answers[pid].value);
        if (!Number.isFinite(rep)) continue;

        const at = Number(answers[pid].at) || 0;
        const diff = Math.abs(rep - correct);
        const pts = Math.max(0, 5000 - diff * 500);

        ops.push(incrementScore(pid, pts));

        const answeredMs = (at && tsStartNum) ? Math.max(0, at - tsStartNum) : null;
        ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
          lastDelta: pts,
          lastAnswerValue: rep,
          lastAnswerDiff: diff,
          lastAnswerMs: answeredMs
        }));

        const p = playersMap[pid] || {};
        const badges = [];
        if (diff === 0) badges.push('perfect');
        if (answeredMs != null && answeredMs < FAST_MS) badges.push('fast');
        if (diff <= 1 && diff > 0) badges.push('close');

        podiumArray.push({
          id: pid, name: p.name || "‚Äî",
          avatar: p.avatar || "https://api.dicebear.com/7.x/thumbs/svg?seed=Fox",
          value: rep, diff, points: pts,
          ms: answeredMs, badges
        });

        try { ops.push(incrementGlobal(pid, pts)); } catch (_) {}
      }

      for (const pid in playersMap) {
        if (!answers[pid]) {
          ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
            lastDelta: 0, lastAnswerValue: null, lastAnswerDiff: null, lastAnswerMs: null
          }));
        }
      }
      await Promise.all(ops);

      podiumArray.sort((a,b)=> a.diff - b.diff || a.value - b.value);
      const top3 = podiumArray.slice(0, 3);

      if (isHost) { const spells = await loadSpells(); NEXT_SORT_LOCAL = randomSpell(spells); }

      await update(stateRef, { phase: "between", tsStart: serverTimestamp(), top3 });

      setTimeout(async () => {
        const snapshot = await get(playersRef);
        const playersObj = snapshot.val() || {};
        renderLeaderboardFrom(playersObj);
        updateLiveRankChip(playersObj);
        renderBetweenInfo(playersObj);
      }, 50);

      try { await remove(ref(db, `rooms/${ROOM_ID}/answers/${turn}`)); } catch(_) {}

      setTimeout(async () => {
        const p = (await get(playersRef)).val() || {};
        LAST_RANKS = computeRanksMap(p);
      }, 80);
    }

    function incrementScore(pid, delta) {
      const sref = ref(db, `rooms/${ROOM_ID}/players/${pid}/score`);
      return runTransaction(sref, (current) => (Number(current)||0) + delta);
    }

    async function incrementGlobal(pid, delta) {
      try {
        const playerNodeRef = ref(db, `rooms/${ROOM_ID}/players/${pid}`);
        const playerNodeSnap = await get(playerNodeRef);
        const playerNode = playerNodeSnap.val() || {};
        const profSnap = await get(profilesRef(pid));
        const prof = profSnap.val() || {};
        const name = playerNode.name || prof.name || "Invit√©";
        const avatar = playerNode.avatar || prof.avatar || "https://api.dicebear.com/7.x/thumbs/svg?seed=Fox";
        try { await update(profilesRef(pid), { name, avatar, lastSeen: serverTimestamp() }); } catch (_) {}
        try { await update(globalWeekRef(pid), { name, avatar }); const weekScoreRef = ref(db, `leaderboards/weeks/${WEEK_ID}/${pid}/score`); await runTransaction(weekScoreRef, (current)=> (Number(current)||0) + delta); } catch (_) {}
        try { await update(globalSeasonRef(pid), { name, avatar }); const seasonScoreRef = ref(db, `leaderboards/seasons/${SEASON_ID}/${pid}/score`); await runTransaction(seasonScoreRef, (current)=> (Number(current)||0) + delta); } catch (_) {}
      } catch (e) { console.error("incrementGlobal failed:", e?.code || e?.message || e); }
    }

    async function startNextTurn(prevGame) {
      const { turn, settings } = prevGame;
      if (turn >= settings.totalTurns) { await update(stateRef, { turn: settings.totalTurns + 1 }); return; }
      await clearPlayersDeltas();
      let chosen;
      if (isHost && NEXT_SORT_LOCAL) chosen = NEXT_SORT_LOCAL;
      else { const spells = await loadSpells(); chosen = randomSpell(spells); }
      NEXT_SORT_LOCAL = null;

      await set(stateRef, {
        host: prevGame.host, settings,
        turn: turn + 1, phase: "answer",
        sort: chosen, tsStart: serverTimestamp(), top3: null
      });
    }

    async function clearPlayersDeltas() {
      const players = (await get(playersRef)).val() || {};
      const ops = [];
      for (const pid in players) {
        ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
          lastDelta: 0, lastAnswerValue: null, lastAnswerDiff: null, lastAnswerMs: null
        }));
      }
      await Promise.all(ops);
    }

    function computeSortedList(playersObj) {
      const list = Object.entries(playersObj || {}).map(([id,p]) => ({
        id, name: p.name || '‚Äî', avatar: p.avatar, score: Number(p.score)||0, lastDelta: Number(p.lastDelta)||0
      }));
      list.sort((a,b) => (b.score - a.score) || a.name.localeCompare(b.name));
      return list;
    }
    function computeRanksMap(playersObj) {
      const list = computeSortedList(playersObj);
      const map = {};
      list.forEach((p, idx) => map[p.id] = idx + 1);
      return map;
    }

    function updateLiveRankChip(playersObj) {
      if (!uid) return;
      const list = computeSortedList(playersObj);
      const rank = list.findIndex(p => p.id === uid) + 1;
      const total = list.length || 0;
      const chip = el('myLiveRank');
      if (!rank || !total) { chip.textContent = "Mon rang : ‚Äî"; return; }
      chip.textContent = `Mon rang : ${rank}/${total}`;
    }

    // FLIP animation for leaderboard reorder + crown animation for leader
    function renderLeaderboardFrom(playersObj) {
      const container = el('leaderboard');
      const list = computeSortedList(playersObj);
      const showDelta = (GAME_CACHE && GAME_CACHE.phase === 'between');

      // measure first
      const prevRects = new Map();
      Array.from(container.children).forEach(child => {
        const id = child.getAttribute('data-id');
        if (id) prevRects.set(id, child.getBoundingClientRect());
      });

      // build new markup
      const rowsHtml = list.map((p, idx) => {
        const rank = idx + 1;
        const prev = LAST_RANKS[p.id];
        let posDelta = 0;
        if (prev != null) posDelta = prev - rank;
        const arrow = posDelta > 0 ? `‚Üë${posDelta}` : posDelta < 0 ? `‚Üì${Math.abs(posDelta)}` : '‚Äì';
        const podiumCls = rank<=3 ? ` lb-${rank}` : '';
        const crown = rank === 1 ? `<span class="crown" title="Leader"></span>` : '';

        return `
          <div class="lb-row${podiumCls}" data-id="${p.id}">
            <div class="lb-rank">${rank}</div>
            <img class="lb-avatar" src="${safeUrl(p.avatar)}" alt="">
            <div class="lb-name">${crown}${crown ? '&nbsp;' : ''}${escapeHtml(p.name)}</div>
            <div class="lb-score">${p.score}${showDelta && p.lastDelta ? `<span class="lb-delta">(+${p.lastDelta})</span>` : ''}<span class="lb-posdelta"> ${arrow}</span></div>
          </div>
        `;
      }).join('') || `<div class="muted">Aucun joueur pour le moment.</div>`;

      container.innerHTML = rowsHtml;

      // measure last & play
      Array.from(container.children).forEach(child => {
        const id = child.getAttribute('data-id');
        if (!id) return;
        const last = child.getBoundingClientRect();
        const first = prevRects.get(id);
        if (!first) return;
        const dy = first.top - last.top;
        if (Math.abs(dy) > 1) {
          child.style.transform = `translateY(${dy}px)`;
          child.style.transition = 'transform 0s';
          requestAnimationFrame(() => {
            child.style.transition = 'transform .35s ease';
            child.style.transform = 'translateY(0)';
          });
        }
      });

      // store ranks for next delta computation (posDelta arrow)
      LAST_RANKS = {};
      list.forEach((p, i)=> LAST_RANKS[p.id] = i+1);
    }

    function renderBetweenInfo(playersObj) {
      if (GAME_OVER || !GAME_CACHE || GAME_CACHE.phase !== 'between') { el('betweenInfo').innerHTML = ''; return; }
      const correct = GAME_CACHE?.sort?.cd;
      const me = playersObj?.[uid] || {};
      const myVal  = (me.lastAnswerValue != null && me.lastAnswerValue !== '') ? `${me.lastAnswerValue} sec` : '‚Äî';
      const myDiff = (me.lastAnswerDiff  != null && me.lastAnswerDiff  !== '') ? `${me.lastAnswerDiff} sec`  : '‚Äî';
      const myDeltaNum = (typeof me.lastDelta === 'number') ? me.lastDelta : 0;
      const myDeltaTxt = myDeltaNum > 0 ? `+${myDeltaNum}` : '+0';
      const top3 = Array.isArray(GAME_CACHE.top3) ? GAME_CACHE.top3 : [];

      const podiumHtml = top3.length ? `
        <div id="podium">
          ${top3.map((p, i)=> {
            const perfect = p.badges?.includes('perfect') ? ` <span class="badge b-perfect">üèÖ Perfect!</span>` : '';
            const fast    = p.badges?.includes('fast')    ? ` <span class="badge b-fast">‚ö° Rapid</span>` : '';
            const close   = p.badges?.includes('close')   ? ` <span class="badge b-close">üéØ Proche</span>` : '';
            const msTxt   = (typeof p.ms === 'number') ? ` ‚Äî ${(p.ms/1000).toFixed(2)}s` : '';
            return `
              <div class="podium-row">
                <div class="podium-rank">${i+1}</div>
                <img class="podium-avatar" src="${safeUrl(p.avatar)}" alt="">
                <div class="podium-name">${escapeHtml(p.name)}</div>
                <div class="podium-meta">${p.value}s (√©cart ${p.diff}s)${msTxt} ¬∑ +${p.points}${perfect}${fast}${close}</div>
              </div>
            `;
          }).join('')}
        </div>` : `<div class="muted" style="margin-top:6px;">Pas de podium ce tour.</div>`;

      el('betweenInfo').innerHTML = `
        <div class="answer-burst pop-in" aria-live="polite">
          ‚úÖ R√©ponse correcte&nbsp;: <span style="font-variant-numeric: tabular-nums">${correct}</span> sec
        </div>
        <div class="muted" style="margin-top:6px;">
          <strong>Ta r√©ponse :</strong> ${myVal} &nbsp;|&nbsp; 
          <strong>√âcart :</strong> ${myDiff} &nbsp;|&nbsp; 
          <strong>Points :</strong> ${myDeltaTxt}
        </div>
        <h4 style="margin:10px 0 6px;">üèÖ Top 3 meilleures r√©ponses</h4>
        ${podiumHtml}
      `;
    }

    function finDePartie(hostId) {
      GAME_OVER = true;
      if (timerInterval) clearInterval(timerInterval);
      if (progressRAF) { cancelAnimationFrame(progressRAF); progressRAF = null; }
      el('timer').classList.remove('timer-final');
      if (flashLayer) flashLayer.classList.remove('show');
      el('timerBar').style.transform = 'scaleX(0)';

      el("sortDisplay").innerHTML = "üéâ Fin de la partie !";
      el("answerSection").classList.add("hidden");
      el("status").textContent = "Merci d‚Äôavoir jou√© !";
      el("timer").textContent = "";

      get(playersRef).then(s => { 
        renderLeaderboardFrom(s.val() || {});
      });

      const showRestart = hostId === uid;
      el("restartRow").style.display = showRestart ? "block" : "none";
    }

    el("restartBtn").addEventListener("click", async () => {
      try {
        const resetScores = el("resetScores").checked;
        const st = (await get(stateRef)).val();
        if (!st || st.host !== uid) { alert("Seul l'h√¥te peut relancer la partie."); return; }

        GAME_OVER = false;
        NEXT_SORT_LOCAL = null;

        if (resetScores) {
          const players = (await get(playersRef)).val() || {};
          const ops = Object.keys(players).map(pid => update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), { score: 0 }));
          await Promise.all(ops);
        }

        const turnsSnap = await get(answersRef);
        const turns = turnsSnap.val() || {};
        await Promise.all(Object.keys(turns).map(t => remove(ref(db, `rooms/${ROOM_ID}/answers/${t}`))));
        await clearPlayersDeltas();

        const spells = await loadSpells();
        const first = randomSpell(spells);
        const totalTurns   = st.settings?.totalTurns   ?? 10;
        const turnDuration = st.settings?.turnDuration ?? 30;

        await set(stateRef, {
          host: st.host, settings: { totalTurns, turnDuration, delayBetween: DELAY_BETWEEN },
          turn: 1, phase: "answer", sort: first, tsStart: serverTimestamp(), top3: null
        });

        LAST_RANKS = {};
        LAST_PHASE = 'answer';
        HISTORY = [];
        bumpLocalGames();

        el("restartRow").style.display = "none";
        el("waitingHost").style.display = "none";
      } catch (e) {
        console.error("Relance √©chou√©e:", e);
        alert("Relance impossible : " + (e?.message || e));
      }
    });

    const globalModal = el('globalModal');
    el('openGlobalBtn').addEventListener('click', async (ev)=>{
      ev.preventDefault();
      el('weekLabel').textContent = WEEK_ID;
      globalModal.style.display = 'flex';
      await renderGlobalTop();
    });
    el('closeGlobal').addEventListener('click', ()=> globalModal.style.display = 'none');
    globalModal.addEventListener('click', (e)=>{ if (e.target === globalModal) globalModal.style.display = 'none'; });

    async function renderGlobalTop() {
      const qref = query(ref(db, `leaderboards/weeks/${WEEK_ID}`), orderByChild('score'), limitToLast(50));
      const snap = await get(qref);
      const data = snap.val() || {};
      const arr = Object.entries(data).map(([id, v]) => ({ id, name: v.name||'‚Äî', avatar: v.avatar, score: Number(v.score)||0 }));
      arr.sort((a,b)=> b.score - a.score);

      if (arr.length === 0) {
        el('globalList').innerHTML = `<div class="muted">Aucun score cette semaine pour l'instant. Joue un tour pour entrer au classement !</div>`;
        return;
      }

      const html = arr.map((p, i)=> `
        <div class="global-row">
          <div class="global-rank">${i+1}</div>
          <img class="lb-avatar" src="${safeUrl(p.avatar||'https://api.dicebear.com/7.x/thumbs/svg?seed=Fox')}" alt="">
          <div class="global-name">${escapeHtml(p.name)}</div>
          <div class="lb-score">${p.score}</div>
        </div>
      `).join('');
      el('globalList').innerHTML = html;
    }

    async function kickIfHostAFK() {
      const stSnap = await get(stateRef);
      const st = stSnap.val();
      if (!st || !st.host) return;

      const hostId = st.host;
      const hostNode = (await get(ref(db, `rooms/${ROOM_ID}/players/${hostId}`))).val();
      const lastSeen = hostNode?.lastSeen;
      if (!lastSeen) return;

      const stale = Date.now() - Number(lastSeen) > 5*60*1000;
      if (!stale) return;

      const players = (await get(playersRef)).val() || {};
      const candidates = Object.entries(players)
        .filter(([id,p]) => id !== hostId && p.lastSeen && (Date.now() - Number(p.lastSeen) <= 5*60*1000))
        .sort((a,b) => (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      if (!candidates.length) return;

      const newHostId = candidates[0][0];
      await runTransaction(ref(db, `rooms/${ROOM_ID}/state/host`), (current) => current === hostId ? newHostId : current);
      try { await remove(ref(db, `rooms/${ROOM_ID}/players/${hostId}`)); } catch(_) {}
    }
    setInterval(kickIfHostAFK, 30*1000);
    onValue(stateRef, () => { kickIfHostAFK(); });

    document.getElementById('toggleHistory').addEventListener('click', ()=>{
      document.getElementById('historyWrap').classList.toggle('hidden');
      renderHistory();
    });

    function loadStats() {
      try { return JSON.parse(localStorage.getItem('cdg_stats_v1')) || { games:0, rounds:0, perfects:0, streak:0, bestStreak:0, sumDiff:0 }; }
      catch { return { games:0, rounds:0, perfects:0, streak:0, bestStreak:0, sumDiff:0 }; }
    }
    function saveStats() { localStorage.setItem('cdg_stats_v1', JSON.stringify(STATS)); }
    function renderStatsChips() {
      const avg = STATS.rounds ? (STATS.sumDiff / STATS.rounds) : 0;
      const pct = STATS.rounds ? Math.round((STATS.perfects / STATS.rounds) * 100) : 0;
      el('chipGames').textContent  = `Parties: ${STATS.games}`;
      el('chipRounds').textContent = `Tours jou√©s: ${STATS.rounds}`;
      el('chipPerfect').textContent= `Perfects: ${STATS.perfects} (${pct}%)`;
      el('chipAvg').textContent    = STATS.rounds ? `Diff moyen: ${avg.toFixed(2)}` : 'Diff moyen: ‚Äî';
      el('chipStreak').textContent = `S√©rie perfect: ${STATS.streak} (best ${STATS.bestStreak})`;
    }
    function bumpLocalGames(){ STATS.games++; saveStats(); renderStatsChips(); }

    function updateLocalStatsAndHistory(playersObj, game) {
      const me = playersObj?.[uid] || {};
      if (me == null) return;
      if (me.lastAnswerDiff != null) {
        STATS.rounds++;
        const d = Number(me.lastAnswerDiff) || 0;
        STATS.sumDiff += d;
        if (d === 0) { STATS.perfects++; STATS.streak++; STATS.bestStreak = Math.max(STATS.bestStreak, STATS.streak); }
        else { STATS.streak = 0; }
        saveStats(); renderStatsChips();
      }

      const sort = game?.sort || {};
      const badges = [];
      if (me.lastAnswerDiff === 0) badges.push('perfect');
      if (typeof me.lastAnswerMs === 'number' && me.lastAnswerMs < FAST_MS) badges.push('fast');
      if (me.lastAnswerDiff > 0 && me.lastAnswerDiff <= 1) badges.push('close');

      HISTORY.push({
        champ: sort.champ, key: sort.key, name: sort.name,
        correct: sort.cd, value: me.lastAnswerValue, diff: me.lastAnswerDiff,
        points: me.lastDelta, ms: me.lastAnswerMs, badges
      });
      renderHistory();
    }

    function renderHistory() {
      const list = document.getElementById('historyList');
      if (!HISTORY.length) { list.innerHTML = `<div class="muted">Aucun tour pour l‚Äôinstant.</div>`; return; }
      list.innerHTML = HISTORY.map(h => {
        const perfect = h.badges.includes('perfect') ? ` <span class="badge b-perfect">üèÖ Perfect!</span>` : '';
        const fast    = h.badges.includes('fast')    ? ` <span class="badge b-fast">‚ö° Rapid</span>` : '';
        const close   = h.badges.includes('close')   ? ` <span class="badge b-close">üéØ Proche</span>` : '';
        const msTxt   = (typeof h.ms === 'number') ? ` ‚Äî ${(h.ms/1000).toFixed(2)}s` : '';
        return `
          <div class="hrow">
            <div style="min-width:120px"><strong>${escapeHtml(h.champ||'?')} ${h.key||''}</strong></div>
            <div style="flex:1; opacity:.9;">${escapeHtml(h.name||'')}</div>
            <div><strong>${h.value ?? '‚Äî'}</strong> / ${h.correct} (√©cart ${h.diff ?? '‚Äî'})${msTxt} ¬∑ +${h.points ?? 0}${perfect}${fast}${close}</div>
          </div>
        `;
      }).join('');
    }

    function clampInt(val, min, max) { const n = parseInt(val, 10); if (isNaN(n)) return min; return Math.max(min, Math.min(max, n)); }
    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

    window.addEventListener("beforeunload", ()=> {
      if (timerInterval) clearInterval(timerInterval);
      if (progressRAF) cancelAnimationFrame(progressRAF);
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      if (flashLayer) flashLayer.classList.remove('show');
    });
  </script>
</body>
</html>
