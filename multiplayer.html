<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cooldown Multiplayer (Rooms)</title>
  <style>
    body { font-family: Montserrat, system-ui, -apple-system, sans-serif; background:#1e3c72; color:#fff; padding:30px; text-align:center; }
    input, button, select { font-size:1rem; padding:10px; margin:10px; border-radius:6px; border:none; }
    button { cursor:pointer }
    a.btn { text-decoration:none; background:#ffd700; color:#222; font-weight:700; padding:8px 12px; border-radius:8px; }
    #topRight { position:fixed; top:12px; right:12px; display:flex; gap:8px; z-index:10; }
    #game, #settingsContainer, #waitingHost { display:none; }
    #startGameBtn { display:none; }
    .player-grid { display:flex; justify-content:center; gap:16px; flex-wrap:wrap; margin:20px 0; }
    .player-card { background-color:rgba(255,255,255,0.1); padding:10px; border-radius:8px; min-width:140px; }
    .avatar { width:40px; height:40px; border-radius:50%; object-fit:cover; margin-bottom:5px; background:#fff; }
    #feedback { font-size:0.95rem; margin-top:8px; color:#90ee90; min-height:1.2em; }
    #status { opacity:.85; font-size:.95rem; min-height:1.2em; }
    .hidden { display:none }
    .muted { opacity:.75 }

    /* Leaderboard */
    #leaderboardSection { margin-top:18px; }
    .lb-row { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.08); margin:8px 0; transition: transform .25s ease, background-color .25s ease; }
    .lb-rank { width:34px; text-align:center; font-weight:800; }
    .lb-avatar { width:32px; height:32px; border-radius:50%; background:#fff; object-fit:cover; }
    .lb-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center; gap:6px; }
    .lb-score { font-weight:800; }
    .lb-delta { font-weight:800; margin-left:8px; }
    .lb-posdelta { font-weight:700; margin-left:8px; }
    .lb-1 { background:linear-gradient(90deg, rgba(255,215,0,.22), transparent); }
    .lb-2 { background:linear-gradient(90deg, rgba(192,192,192,.22), transparent); }
    .lb-3 { background:linear-gradient(90deg, rgba(205,127,50,.22), transparent); }

    /* Animations classement */
    .gain { background-color: rgba(76,175,80,0.18); }
    .loss { background-color: rgba(244,67,54,0.18); }
    .pulse { animation: pulse 0.9s ease-out 1; }
    .rise  { animation: rise 0.45s ease-out 1; }
    .fall  { animation: fall 0.45s ease-out 1; }
    @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.03)} 100%{transform:scale(1)} }
    @keyframes rise  { 0%{transform:translateY(6px)} 100%{transform:translateY(0)} }
    @keyframes fall  { 0%{transform:translateY(-6px)} 100%{transform:translateY(0)} }

    /* Between info */
    #betweenInfo { margin-top:16px; background:rgba(255,255,255,0.08); border-radius:10px; padding:10px 12px; max-width:520px; margin-left:auto; margin-right:auto; }
  </style>
</head>
<body>
  <!-- Boutons en haut √† droite -->
  <div id="topRight">
    <a href="index.html" class="btn" title="Aller au mode Solo">üè† Solo</a>
    <a id="shareBtn" class="btn" href="#" title="Copier le lien du salon">üîó Lien du salon</a>
  </div>

  <div id="welcome">
    <h1>Multiplayer Cooldown Trainer</h1>
    <div id="roomInfo" class="muted" style="margin-bottom:8px;"></div>
    <input id="nameInput" placeholder="Ton pseudo..." maxlength="24"/>
    <select id="avatarSelect" title="Avatar">
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Fox">ü¶ä Avatar 1</option>
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Cat">üê± Avatar 2</option>
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Robot">ü§ñ Avatar 3</option>
      <option value="https://api.dicebear.com/7.x/thumbs/svg?seed=Dragon">üêâ Avatar 4</option>
    </select>
    <button id="joinBtn">Rejoindre</button>
    <div id="joinError" class="muted"></div>
  </div>

  <div id="settingsContainer">
    <h3>Param√©trer la partie</h3>
    <label>Nombre de tours:
      <input type="number" id="nbTours" value="10" min="1" max="50">
    </label>
    <label>Temps par tour (s):
      <input type="number" id="tempsTour" value="30" min="5" max="300">
    </label>
    <div class="muted">Pause entre tours : 10s</div>
    <br>
    <button id="startGameBtn">üéÆ Lancer la partie</button>
  </div>

  <div id="waitingHost">
    <p>‚è≥ En attente que l'h√¥te lance la partie...</p>
  </div>

  <div id="game">
    <div id="status" class="muted"></div>
    <h2>Joueurs connect√©s</h2>
    <div class="player-grid" id="players"></div>

    <div id="sortDisplay" style="margin-top:16px;font-size:1.2rem;min-height:1.8em;"></div>
    <div id="timer" style="font-size:1.6rem;margin:10px 0;min-height:1.6em;"></div>

    <div id="answerSection" class="hidden">
      <input id="answerInput" placeholder="Cooldown en sec" inputmode="numeric" pattern="[0-9]*" maxlength="3">
      <button id="submitBtn">Envoyer</button>
      <div id="feedback"></div>
    </div>

    <!-- Infos entre les tours -->
    <div id="betweenInfo" class="hidden"></div>

    <!-- Classement entre les tours -->
    <div id="leaderboardSection" class="hidden">
      <h3 style="margin:8px 0;">Classement</h3>
      <div id="leaderboard" style="max-width:560px;margin:0 auto;text-align:left;"></div>
    </div>

    <!-- Fin de partie : relancer -->
    <div id="restartRow" style="margin-top:14px; display:none">
      <label style="font-size:.95rem">
        <input type="checkbox" id="resetScores" checked>
        R√©initialiser les scores
      </label>
      <button id="restartBtn">üîÅ Relancer la partie</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, set, onValue, onDisconnect, update, get, remove,
      serverTimestamp, runTransaction
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    // -------- Firebase --------
    const firebaseConfig = {
      apiKey: "AIzaSyBjkxLbnCBZYvcyNRrGxwphT6nCyPOcGfI",
      authDomain: "cdguesser.firebaseapp.com",
      projectId: "cdguesser",
      storageBucket: "cdguesser.appspot.com",
      messagingSenderId: "1094034546231",
      appId: "1:1094034546231:web:1baaeca8470b211cf529b2",
      databaseURL: "https://cdguesser-default-rtdb.europe-west1.firebasedatabase.app"
    };
    const app  = initializeApp(firebaseConfig);
    const db   = getDatabase(app);
    const auth = getAuth(app);

    // -------- Constantes jeu --------
    const DELAY_BETWEEN = 10; // ‚è∏Ô∏è pause FIXE 10s entre les tours

    // -------- Room handling --------
    function getRoomId() {
      const url = new URL(window.location.href);
      let id = url.searchParams.get('room');
      if (!id) {
        id = Math.random().toString(36).slice(2, 8);
        url.searchParams.set('room', id);
        history.replaceState(null, '', url.toString());
      }
      return id;
    }
    const ROOM_ID = getRoomId();
    const playersRef  = ref(db, `rooms/${ROOM_ID}/players`);
    const stateRef    = ref(db, `rooms/${ROOM_ID}/state`);
    const answersRef  = ref(db, `rooms/${ROOM_ID}/answers`);

    // UI share
    const shareBtn = document.getElementById('shareBtn');
    document.getElementById('roomInfo').textContent = `Salon : ${ROOM_ID}`;
    shareBtn.href = window.location.href;
    shareBtn.onclick = async (e) => {
      e.preventDefault();
      try { await navigator.clipboard.writeText(window.location.href); shareBtn.textContent = '‚úÖ Lien copi√©'; setTimeout(()=>shareBtn.textContent='üîó Lien du salon',1500);} catch(_) {}
    };

    // -------- State --------
    let uid = null;
    let isHost = false;
    let cacheSpells = null;
    let timerInterval = null;
    let lastSpellKey = null;
    const AFK_LIMIT_MS = 5 * 60 * 1000;
    let heartbeatInterval = null;
    let GAME_CACHE = null;

    // Classement : m√©morisation du rang pr√©c√©dent
    let LAST_RANKS = {};
    let LAST_PHASE = null;

    // -------- Helpers DOM --------
    const el = (id)=>document.getElementById(id);

    // -------- Auth anonyme (√† la demande) --------
    onAuthStateChanged(auth, (u) => { if (u) uid = u.uid; });
    async function ensureAuth() {
      if (auth.currentUser) { uid = auth.currentUser.uid; return uid; }
      try {
        const cred = await signInAnonymously(auth);
        uid = cred.user.uid;
        return uid;
      } catch (e) {
        console.error("signInAnonymously failed:", e);
        const msg = (e && e.code) || e?.message || String(e);
        let hint = "";
        if (msg.includes("auth/configuration-not-found") || msg.includes("auth/operation-not-allowed")) {
          hint = " ‚û°Ô∏è Active l'auth anonyme (Authentication > Sign-in method) et ajoute ton domaine dans Authorized domains.";
        }
        el("joinError").textContent = "Impossible de se connecter (auth)." + hint;
        throw e;
      }
    }

    // -------- Spells --------
    async function loadSpells() {
      if (cacheSpells) return cacheSpells;
      const res = await fetch("data/championFull.json");
      const data = await res.json();
      const arr = [];
      for (const key in data.data) {
        const champ = data.data[key];
        champ.spells.forEach((spell, i) => {
          const cd = Array.isArray(spell.cooldown) ? spell.cooldown[0] : spell.cooldown;
          arr.push({ champ: champ.name, key: ['Q','W','E','R'][i], cd: Number(cd), name: spell.name });
        });
      }
      cacheSpells = arr;
      return arr;
    }
    function randomSpell(spells) {
      let s;
      for (let tries=0; tries<5; tries++) {
        s = spells[Math.floor(Math.random()*spells.length)];
        const key = s.champ + "|" + s.key;
        if (key !== lastSpellKey) { lastSpellKey = key; break; }
      }
      return s;
    }

    // -------- Join flow --------
    el("joinBtn").addEventListener("click", async () => {
      const name = el("nameInput").value.trim().slice(0,24);
      const avatar = el("avatarSelect").value;
      if (!name) { el("joinError").textContent = "Pseudo requis"; return; }

      try { await ensureAuth(); } catch { return; }

      const myRef = ref(db, `rooms/${ROOM_ID}/players/${uid}`);
      await set(myRef, { name, avatar, score: 0, joinedAt: serverTimestamp(), lastSeen: serverTimestamp(), lastDelta: 0, lastAnswerValue: null, lastAnswerDiff: null });
      onDisconnect(myRef).remove();

      el("welcome").style.display = "none";
      el("game").style.display = "block";

      const stateSnap = await get(stateRef);
      const st = stateSnap.val();
      if (!st || !st.host) {
        isHost = true;
        await update(stateRef, { host: uid });
        el("settingsContainer").style.display = "block";
        el("startGameBtn").style.display = "inline-block";
        el("waitingHost").style.display = "none";
        el("status").textContent = "Vous √™tes l'h√¥te.";
      } else {
        isHost = (st.host === uid);
        if (!isHost) {
          el("waitingHost").style.display = "block";
          el("status").textContent = "En attente du lancement par l'h√¥te‚Ä¶";
        }
      }

      startHeartbeat();
    });

    function startHeartbeat(){
      const ping = async ()=> { try { await update(ref(db, `rooms/${ROOM_ID}/players/${uid}`), { lastSeen: serverTimestamp() }); } catch(_){} };
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      heartbeatInterval = setInterval(ping, 30*1000);
      ['pointerdown','keydown','touchstart'].forEach(ev => document.addEventListener(ev, ping, { passive: true }));
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) ping(); });
      ping();
    }

    // -------- Players list + leaderboard binding --------
    const playersList = el("players");
    let renderLeaderboardLastPlayersSnapshot = null;

    onValue(playersRef, async (snapshot) => {
      const data = snapshot.val() || {};
      playersList.innerHTML = "";
      const entries = Object.entries(data).sort((a,b)=> (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      for (const [id, p] of entries) {
        const card = document.createElement("div");
        card.className = "player-card";
        card.innerHTML = `
          <img src="${p.avatar}" class="avatar" alt="">
          <div><strong>${escapeHtml(p.name||"")}</strong></div>
          <div>Score : ${Number(p.score)||0}</div>`;
        playersList.appendChild(card);
      }
      await reassignHostIfNeeded(data);

      renderLeaderboardLastPlayersSnapshot = () => { renderLeaderboardFrom(data); if (GAME_CACHE?.phase === 'between') renderBetweenInfo(data); };
      if (GAME_CACHE && GAME_CACHE.phase === 'between') {
        renderLeaderboardFrom(data);
        renderBetweenInfo(data);
      }
    });

    async function reassignHostIfNeeded(playersObj) {
      const snap = await get(stateRef);
      const st = snap.val();
      if (!st || !st.host) return;
      if (!playersObj[st.host]) {
        const firstId = Object.keys(playersObj)[0];
        if (!firstId) { await set(stateRef, {}); return; }
        await update(stateRef, { host: firstId });
        if (firstId === uid) {
          isHost = true;
          el("settingsContainer").style.display = "block";
          el("startGameBtn").style.display = "inline-block";
          el("waitingHost").style.display = "none";
          el("status").textContent = "Vous √™tes devenu l'h√¥te.";
        }
      }
    }

    // -------- Lancer la partie (h√¥te) --------
    el("startGameBtn").addEventListener("click", async () => {
      if (!isHost) return alert("Seul l'h√¥te peut lancer la partie !");
      const totalTurns   = clampInt(el("nbTours").value, 1, 50);
      const turnDuration = clampInt(el("tempsTour").value, 5, 300);

      const spells = await loadSpells();
      const first = randomSpell(spells);

      await set(stateRef, {
        host: uid,
        settings: { totalTurns, turnDuration, delayBetween: DELAY_BETWEEN }, // üîí 10s fix√©
        turn: 1,
        phase: "answer",
        sort: first,
        tsStart: serverTimestamp()
      });

      el("settingsContainer").style.display = "none";
      el("waitingHost").style.display = "none";
      clearPlayersDeltas();
      LAST_RANKS = {};
      LAST_PHASE = 'answer';
    });

    // -------- Soumettre une r√©ponse (derni√®re gagnante) --------
    el("submitBtn").addEventListener("click", async () => {
      const v = el("answerInput").value.trim();
      if (!/^\d{1,3}$/.test(v)) { el("feedback").textContent = "‚ö†Ô∏è Entrez un nombre (0‚Äì999)."; return; }
      const val = clampInt(v, 0, 999);
      const st = (await get(stateRef)).val();
      if (!st || st.phase !== "answer") { el("feedback").textContent = "Tour verrouill√©."; return; }
      await set(ref(db, `rooms/${ROOM_ID}/answers/${st.turn}/${uid}`), { value: val, at: serverTimestamp() });
      el("feedback").textContent = "‚úÖ R√©ponse enregistr√©e";
    });

    // -------- Boucle de jeu (√©coute de l'√©tat) --------
    onValue(stateRef, (snap) => {
      const game = snap.val();
      if (!game || !game.settings) return;
      renderGame(game);
      setupTimer(game);

      // üëâ Forcer l'affichage between pour TOUS les clients d√®s le changement d'√©tat
      if (game.phase === 'between') {
        setTimeout(async () => {
          const snapPlayers = await get(playersRef);
          const playersObj = snapPlayers.val() || {};
          renderLeaderboardFrom(playersObj);
          renderBetweenInfo(playersObj);
        }, 100); // laisse le temps au host d'√©crire lastDelta/lastAnswer*
      }
    });

    function renderGame(game) {
      if (LAST_PHASE !== game.phase && game.phase === 'answer') {
        // on figera LAST_RANKS √† l‚Äôentr√©e du prochain between
      }
      LAST_PHASE = game.phase;

      GAME_CACHE = game;

      const { turn, settings, phase, sort, host } = game;
      const { totalTurns, delayBetween } = settings;
      if (turn > totalTurns) { finDePartie(host); return; }

      el("answerSection").classList.toggle("hidden", phase !== "answer");
      el("leaderboardSection").classList.toggle("hidden", phase !== "between");
      el("betweenInfo").classList.toggle("hidden", phase !== "between");

      el("sortDisplay").innerHTML = sort ? `<strong>${sort.champ} ${sort.key}</strong> ‚Äî ${sort.name}` : "";
      el("feedback").textContent = "";
      el("status").textContent = (phase === "answer")
        ? `Tour ${turn}/${totalTurns} ‚Äî R√©pondez !`
        : `Tour ${turn}/${totalTurns} termin√©. Prochain dans ${delayBetween}s‚Ä¶`;

      el("restartRow").style.display = "none";
    }

    function setupTimer(game) {
      clearInterval(timerInterval);
      const { settings, phase, tsStart } = game;
      const per = (phase === "answer") ? settings.turnDuration : settings.delayBetween;
      if (!tsStart) { el("timer").textContent = ""; return; }

      const startedAt = Number(game.tsStart);
      let secondsLeft = per - Math.floor((Date.now() - startedAt)/1000);
      if (!Number.isFinite(secondsLeft)) secondsLeft = per;
      secondsLeft = Math.max(0, Math.min(per, secondsLeft));
      el("timer").textContent = `${secondsLeft}s`;

      timerInterval = setInterval(async () => {
        secondsLeft--;
        el("timer").textContent = `${secondsLeft}s`;
        if (secondsLeft <= 0) {
          clearInterval(timerInterval);
          if (isHost) {
            if (phase === "answer") await closeAndScoreTurn(game);
            else if (phase === "between") await startNextTurn(game);
          }
        }
      }, 1000);
    }

    // -------- Scoring --------
    async function closeAndScoreTurn(game) {
      const turn = game.turn;
      const answersSnap = await get(ref(db, `rooms/${ROOM_ID}/answers/${turn}`));
      const answers = answersSnap.val() || {};
      const correct = Number(game.sort.cd);

      const ops = [];
      for (const pid in answers) {
        const rep = Number(answers[pid].value);
        if (Number.isFinite(rep)) {
          const diff = Math.abs(rep - correct);
          const pts = Math.max(0, 5000 - diff * 500);
          ops.push(incrementScore(pid, pts));
          ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
            lastDelta: pts,
            lastAnswerValue: rep,
            lastAnswerDiff: diff
          }));
        }
      }
      const players = (await get(playersRef)).val() || {};
      for (const pid in players) {
        if (!answers[pid]) {
          ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
            lastDelta: 0,
            lastAnswerValue: null,
            lastAnswerDiff: null
          }));
        }
      }
      await Promise.all(ops);

      await update(stateRef, { phase: "between", tsStart: serverTimestamp() });

      // ‚ûï Rendu imm√©diat des infos comparatives (filet de s√©curit√© suppl√©mentaire)
      setTimeout(async () => {
        const snapshot = await get(playersRef);
        const playersObj = snapshot.val() || {};
        renderLeaderboardFrom(playersObj);
        renderBetweenInfo(playersObj);
      }, 50);

      try { await remove(ref(db, `rooms/${ROOM_ID}/answers/${turn}`)); } catch(_) {}

      // photo des rangs pour l'animation
      setTimeout(async () => {
        const p = (await get(playersRef)).val() || {};
        LAST_RANKS = computeRanksMap(p);
      }, 80);
    }

    async function startNextTurn(prevGame) {
      const { turn, settings } = prevGame;
      if (turn >= settings.totalTurns) {
        await update(stateRef, { turn: settings.totalTurns + 1 });
        return;
      }
      await clearPlayersDeltas();

      const spells = await loadSpells();
      const next = randomSpell(spells);
      await set(stateRef, {
        host: prevGame.host,
        settings,
        turn: turn + 1,
        phase: "answer",
        sort: next,
        tsStart: serverTimestamp()
      });
    }

    function incrementScore(pid, delta) {
      const sref = ref(db, `rooms/${ROOM_ID}/players/${pid}/score`);
      return runTransaction(sref, (current) => (Number(current)||0) + delta);
    }

    async function clearPlayersDeltas() {
      const players = (await get(playersRef)).val() || {};
      const ops = [];
      for (const pid in players) {
        ops.push(update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), {
          lastDelta: 0,
          lastAnswerValue: null,
          lastAnswerDiff: null
        }));
      }
      await Promise.all(ops);
    }

    // -------- Leaderboard (+points & variations de places) --------
    function computeSortedList(playersObj) {
      const list = Object.entries(playersObj || {}).map(([id,p]) => ({
        id, name: p.name || '‚Äî', avatar: p.avatar, score: Number(p.score)||0,
        lastDelta: Number(p.lastDelta)||0
      }));
      list.sort((a,b) => (b.score - a.score) || a.name.localeCompare(b.name));
      return list;
    }
    function computeRanksMap(playersObj) {
      const list = computeSortedList(playersObj);
      const map = {};
      list.forEach((p, idx) => map[p.id] = idx + 1);
      return map;
    }

    function renderLeaderboardFrom(playersObj) {
      const list = computeSortedList(playersObj);
      const showDelta = (GAME_CACHE && GAME_CACHE.phase === 'between');

      const rows = list.map((p, idx) => {
        const rank = idx + 1;
        const prev = LAST_RANKS[p.id];
        let posDelta = 0;
        if (prev != null) posDelta = prev - rank; // positif = mont√©e
        const arrow = posDelta > 0 ? `‚Üë${posDelta}` : posDelta < 0 ? `‚Üì${Math.abs(posDelta)}` : '‚Äì';
        const posCls = posDelta > 0 ? 'gain rise' : posDelta < 0 ? 'loss fall' : '';
        const podiumCls = rank<=3 ? ` lb-${rank} pulse` : '';
        const crown = rank === 1 ? 'üëë' : '';

        return `
          <div class="lb-row ${podiumCls} ${posCls}">
            <div class="lb-rank">${rank}</div>
            <img class="lb-avatar" src="${p.avatar}" alt="">
            <div class="lb-name">${crown}${crown ? '&nbsp;' : ''}${escapeHtml(p.name)}</div>
            <div class="lb-score">${p.score}${showDelta && p.lastDelta ? `<span class="lb-delta">(+${p.lastDelta})</span>` : ''}<span class="lb-posdelta"> ${arrow}</span></div>
          </div>
        `;
      }).join('') || `<div class="muted">Aucun joueur pour le moment.</div>`;

      el('leaderboard').innerHTML = rows;
    }

    // -------- Affichage "r√©ponse correcte" entre les tours --------
    function renderBetweenInfo(playersObj) {
      if (!GAME_CACHE || GAME_CACHE.phase !== 'between') { el('betweenInfo').innerHTML = ''; return; }
      const correct = GAME_CACHE?.sort?.cd;
      const me = playersObj[uid] || {};
      const myVal = (me.lastAnswerValue != null) ? `${me.lastAnswerValue} sec` : '‚Äî';
      const myDiff = (me.lastAnswerDiff != null) ? `${me.lastAnswerDiff} sec` : '‚Äî';
      const myDelta = (me.lastDelta != null) ? `+${me.lastDelta}` : '+0';

      el('betweenInfo').innerHTML = `
        <div><strong>‚úÖ R√©ponse correcte :</strong> ${correct} sec</div>
        <div class="muted" style="margin-top:6px;">
          <strong>Ta r√©ponse :</strong> ${myVal} &nbsp;|&nbsp; <strong>√âcart :</strong> ${myDiff} &nbsp;|&nbsp; <strong>Points :</strong> ${myDelta}
        </div>
      `;
    }

    // -------- Fin de partie + relance --------
    function finDePartie(hostId) {
      el("sortDisplay").innerHTML = "üéâ Fin de la partie !";
      el("answerSection").classList.add("hidden");
      el("status").textContent = "Merci d‚Äôavoir jou√© !";
      el("timer").textContent = "";
      el("leaderboardSection").classList.remove("hidden");
      get(playersRef).then(s => { 
        const obj = s.val() || {};
        renderLeaderboardFrom(obj);
        renderBetweenInfo(obj);
      });

      const showRestart = hostId === uid;
      el("restartRow").style.display = showRestart ? "block" : "none";
    }

    el("restartBtn").addEventListener("click", async () => {
      try {
        const resetScores = el("resetScores").checked;
        const st = (await get(stateRef)).val();
        if (!st || st.host !== uid) { alert("Seul l'h√¥te peut relancer la partie."); return; }

        if (resetScores) {
          const players = (await get(playersRef)).val() || {};
          const ops = Object.keys(players).map(pid =>
            update(ref(db, `rooms/${ROOM_ID}/players/${pid}`), { score: 0 })
          );
          await Promise.all(ops);
        }

        // üîß Nettoyage compat rules (supprime chaque tour au lieu de answers/ racine)
        const turnsSnap = await get(answersRef);
        const turns = turnsSnap.val() || {};
        await Promise.all(
          Object.keys(turns).map(t => remove(ref(db, `rooms/${ROOM_ID}/answers/${t}`)))
        );

        await clearPlayersDeltas();

        const spells = await loadSpells();
        const first = randomSpell(spells);

        const totalTurns   = st.settings?.totalTurns   ?? 10;
        const turnDuration = st.settings?.turnDuration ?? 30;

        await set(stateRef, {
          host: st.host,
          settings: { totalTurns, turnDuration, delayBetween: DELAY_BETWEEN }, // üîí 10s fix√©
          turn: 1,
          phase: "answer",
          sort: first,
          tsStart: serverTimestamp()
        });

        LAST_RANKS = {};
        LAST_PHASE = 'answer';

        el("restartRow").style.display = "none";
        el("waitingHost").style.display = "none";
      } catch (e) {
        console.error("Relance √©chou√©e:", e);
        alert("Relance impossible : " + (e?.code || e?.message || e));
      }
    });

    // -------- Watchdog AFK h√¥te --------
    async function kickIfHostAFK() {
      const stSnap = await get(stateRef);
      const st = stSnap.val();
      if (!st || !st.host) return;

      const hostId = st.host;
      const hostNode = (await get(ref(db, `rooms/${ROOM_ID}/players/${hostId}`))).val();
      const lastSeen = hostNode?.lastSeen;
      if (!lastSeen) return;

      const stale = Date.now() - Number(lastSeen) > AFK_LIMIT_MS;
      if (!stale) return;

      const players = (await get(playersRef)).val() || {};
      const candidates = Object.entries(players)
        .filter(([id,p]) => id !== hostId && p.lastSeen && (Date.now() - Number(p.lastSeen) <= AFK_LIMIT_MS))
        .sort((a,b) => (Number(a[1].joinedAt||0) - Number(b[1].joinedAt||0)));
      if (!candidates.length) return;

      const newHostId = candidates[0][0];
      await runTransaction(ref(db, `rooms/${ROOM_ID}/state/host`), (current) => current === hostId ? newHostId : current);

      try { await remove(ref(db, `rooms/${ROOM_ID}/players/${hostId}`)); } catch(_) {}
    }
    setInterval(kickIfHostAFK, 30*1000);
    onValue(stateRef, () => { kickIfHostAFK(); });

    // -------- Utils --------
    function clampInt(val, min, max) {
      const n = parseInt(val, 10);
      if (isNaN(n)) return min;
      return Math.max(min, Math.min(max, n));
    }
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    }

    // cleanup
    window.addEventListener("beforeunload", ()=> {
      if (timerInterval) clearInterval(timerInterval);
      if (heartbeatInterval) clearInterval(heartbeatInterval);
    });
  </script>
</body>
</html>
